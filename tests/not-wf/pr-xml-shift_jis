<!-- for Panorama *-->
<?VERBATIM "eg" ?>
<spec>
<header>
<title>拡張可能なマーク付け言語 (XML)</title>
<version>第1.0版</version>
<w3c-designation>PR-xml-971208</w3c-designation>
<w3c-doctype>World Wide Web Consortium</w3c-doctype>
<pubdate><day>8日</day><month>12月</month><year>1997年</year></pubdate>
<notice><p>この草案は，XML WG及び他の関係者によるレビューのためのものであって，公開の議論のためのものではない。
<!-- FINAL EDIT:  FIX --></p></notice>
<publoc>
<loc href="http://www.w3.org/TR/PR-xml-971208">
http://www.w3.org/TR/PR-xml-971208</loc></publoc>
<prevlocs>
<loc href="http://www.w3.org/TR/WD-xml-961114">
http://www.w3.org/TR/WD-xml-961114</loc>
<loc href="http://www.w3.org/TR/WD-xml-lang-970331">
http://www.w3.org/TR/WD-xml-lang-970331</loc>
<loc href="http://www.w3.org/TR/WD-xml-lang-970630">
http://www.w3.org/TR/WD-xml-lang-970630</loc>
<loc href="http://www.w3.org/TR/WD-xml-970807">
http://www.w3.org/TR/WD-xml-970807</loc>
<loc href="http://www.w3.org/TR/WD-xml-971117">
http://www.w3.org/TR/WD-xml-971117</loc>
</prevlocs>
<authlist>
<author><name>Tim Bray</name>
<affiliation>Textuality and Netscape</affiliation>
<email href="mailto:tbray@textuality.com">tbray@textuality.com</email></author>
<author><name>Jean Paoli</name>
<affiliation>Microsoft</affiliation>
<email href="mailto:jeanpa@microsoft.com">jeanpa@microsoft.com</email></author>
<author><name>C. M. Sperberg-McQueen</name>
<affiliation>University of Illinois at Chicago</affiliation>
<email href="mailto:cmsmcq@uic.edu">cmsmcq@uic.edu</email></author>
</authlist>
<status>
      <p>この仕様書は, 1997年12月にWorld Wide Web Consortiumから
公表された勧告案Extensible Markup Language version第1.0版を翻訳し, 技
術的内容を変更することなく作成した仕様書である。This specification 
is a translation of the XML proposed recommendation 1.0
published by the World Wide Web Consortium in December 1997.  It is
intended that specification is technically identical to the original.</p>

<p>原文にある、著作権に関しての記述を次に示す。The
original copyright notice is shown below:</p>

<p>この版のXMLの規定は，公開レビュー及び議論を
目的とする。テキスト及び法律上の注意を改変しない限り，自由に
配布してもよい。This version of the XML specification is for
public review and discussion. It may be distributed freely,
as long as all text and legal notices remain intact.</p>

<p>この仕様書の元となったXML勧告案は，1998年2月にWorld
Wide Web Consortiumから公表されたXML勧告によってすでに置き換
えられている。この標準情報は，XML勧告に従って訂正することを
予定している。The XML Proposed Recommendation is superseded
by the XML Recommendation which was published by the World
Wide Web Consortium in February 1998.  It is intended that 
this specification be revised accordingly in the near future.</p>

<p>この仕様書は，安定したものであって，昨年来の<loc href="http://www.w3.org/XML">XML活動</loc>を通じて作成された，一連の作
業草案を元とする。現在，広範囲に使用されている国際的なテキスト処理の標
準(標準一般化マーク付け言語，Standard Generalized Markup Language, ISO
8879:1986に追加及び訂正を加えたもの)の，WWW上での使用のためにサブセット
化した言語を，この仕様書は，規定する。ISO 8879のどの機能をこの
サブセットに残すか，という決定についての詳細は，<loc href="http://www.w3.org/XML/#WG-decisions">別途用意する</loc>。XMLは，
既にいくつかの商品でサポートされ，XMLをサポートする<loc href="http://www.w3.org/XML/#software">フリーウェア</loc>の数も増えて
いる。XMLに関する公開の論議も，オンラインで<loc href="http://www.w3.org/XML/#discussion">入手できる</loc>。It is a
stable document derived from a series of working drafts produced over
the last year as deliverables of the <loc href="http://www.w3.org/XML">XML activity</loc>.  It specifies a
language created by subsetting an existing, widely used international
text processing standard (Standard Generalized Markup Language, ISO
8879:1986 as amended and corrected) for use on the World Wide Web.
Details of the decisions regarding which features of ISO 8879 to
retain in the subset <loc href="http://www.w3.org/XML/#WG-decisions">are available
separately</loc>.  XML is already supported by some commercial
products, and there are a growing number of <loc href="http://www.w3.org/XML/#software">free implementations</loc>.
Public discussions of XML <loc href="http://www.w3.org/XML/#discussion">are accessible
online</loc>.</p>

<p>この仕様書では，<bibref ref="Berners-Lee"/>に定義する
URI(Uniform Resource Identifier)を使用する。URIの制定作業は進行中であっ
て，<bibref ref="RFC1738"/>及び<bibref ref="RFC1808"/>を更新する予定と
なっている。この作業がRFCとして受け入れられない場合は，この規程内のURI
への参照は，URL(Uniform Resource Locator)への参照に代わる。This
specification uses the term URI, which is defined by <bibref ref="Berners-Lee"/>, a work in progress expected to update <bibref ref="RFC1738"/> and <bibref ref="RFC1808"/>.  Should the work not be
accepted as an RFC, the references to uniform resource identifiers
(URIs) in this specification will become references to uniform
resource locators (URLs).</p>

      <p>XMLの仕様に準拠しているかどうかの基準となるはW3Cのサイトにあ
る原文である。The normative version of the specification is
the English version found at the W3C site.</p>

      <p>この標準情報は原仕様と技術的に同一であることを意図しているが、
翻訳上の誤りはあり得る。Although this technical report is
intended to be technically identical to the original, it may
contain errors from the translation.</p>

      <p>備考: 原規定との規定箇所の対応関係を明らかにするため、この
仕様書の節構成及び節番号は、原規定のそれらをできるだけ保存してい
る。この仕様書のWeb版は、原規定のHTMLタグをそのまま保存している。
</p>
</status>
<!-- out of date
<statusp>This is a W3C Working Draft for review by W3C members and other
interested parties. It is a draft document and may be updated,
replaced, or obsoleted by other documents at any time. It is
inappropriate to use W3C Working Drafts as reference material or to
cite them as other than "work in progress". A list of current W3C
working drafts can be found at 
<loc  href="http://www.w3.org/TR">http://www.w3.org/TR</loc>.</statusp>
<statusp><emph>Note:</emph> Since working drafts are subject to frequent
change, you are advised to reference the above URL, rather than the
URLs for working drafts themselves.</statusp>
<statusp>This work is part of the W3C SGML Activity (for current
status, see <loc href="http://www.w3.org/MarkUp/SGML/Activity"
>http://www.w3.org/MarkUp/SGML/Activity</loc>).</statusp>
<p>The current
draft of this specification 
presupposes the successful completion of the current
work on the &WebSGML;, being prepared by ISO/IEC JTC1 
at the time this draft specification was drafted.
If it is not
adopted in the expected form, some clauses of this specification 
may change,  and some
recommendations now labeled "<termref def="dt-interop">for
interoperability</termref>" will become requirements labeled
"<termref def="dt-compat">for compatibility</termref>".
</p>
<p>The current draft of this specification uses the term 
URI, which is defined by 
<bibref ref="Berners-Lee"/>,
which is work in progress expected to update 
<bibref ref="RFC1738"/> and <bibref ref="RFC1808"/>.
Should the work in this draft not be accepted as an RFC, the
references to uniform resource identifiers (URIs) in this
specification will become references to uniform resource
locators (URLs).</p>
</status> -->
<abstract>
<p>拡張可能なマーク付け言語(XML)はSGMLの簡単な方言であって，この仕様書で，そのすべてを規定する。XMLの目標は，現在のHTMLと同様に，一般性のあるSGMLをウェブ上で配布，受信及び処理できることとする。XMLは実装が容易であって，SGML及びHTMLのどちらに対しても相互運用性を保つ設計がなされている。</p>
</abstract>
<pubstmt>
<p>Chicago, Vancouver, Mountain View, et al.:
World-Wide Web Consortium, XML作業グループ, 1996, 1997.</p>
</pubstmt>
<sourcedesc>
<p>Created in electronic form.</p>
</sourcedesc>
<langusage>
<language id="EN">English</language>
<language id="ebnf">Extended Backus-Naur Form (formal grammar)</language>
</langusage>
<revisiondesc>
<slist>
<sitem>1997-12-03 : CMSMcQ : yet further changes</sitem>
<sitem>1997-12-02 : TB : further changes (see TB to XML WG,
2 December 1997)</sitem>
<sitem>1997-12-02 : CMSMcQ : deal with as many corrections and
comments from the proofreaders as possible:
entify hard-coded document date in pubdate element,
change expansion of entity WebSGML,
update status description as per Dan Connolly (am not sure
about refernece to Berners-Lee et al.),
add 'The' to abstract as per WG decision,
move Relationship to Existing Standards to back matter and
combine with References,
re-order back matter so normative appendices come first,
re-tag back matter so informative appendices are tagged informdiv1,
remove XXX XXX from list of 'normative' specs in prose,
move some references from Other References to Normative References,
add RFC 1738, 1808, and 2141 to Other References (they are not
normative since we do not require the processor to enforce any 
rules based on them),
add reference to 'Fielding draft' (Berners-Lee et al.),
move notation section to end of body,
drop URIchar non-terminal and use SkipLit instead,
lose stray reference to defunct nonterminal 'markupdecls',
move reference to Aho et al. into appendix (Tim's right),
add prose note saying that hash marks and fragment identifiers are
NOT part of the URI formally speaking, and are NOT legal in 
system identifiers (processor 'may' signal an error).
Work through:
Tim Bray reacting to James Clark,
Tim Bray on his own,
Eve Maler,

NOT DONE YET:
change binary / text to unparsed / parsed.
handle James's suggestion about &lt; in attriubte values
uppercase hex characters,
namechar list,
</sitem>
<sitem>1997-12-01 : JB : add some column-width parameters</sitem>
<sitem>1997-12-01 : CMSMcQ : begin round of changes to incorporate
recent WG decisions and other corrections:
binding sources of character encoding info (27 Aug / 3 Sept),
correct wording of Faust quotation (restore dropped line),
drop SDD from EncodingDecl,
change text at version number 1.0,
drop misleading (wrong!) sentence about ignorables and extenders,
modify definition of PCData to make bar on msc grammatical,
change grammar's handling of internal subset (drop non-terminal markupdecls),
change definition of includeSect to allow conditional sections,
add integral-declaration constraint on internal subset,
drop misleading / dangerous sentence about relationship of
entities with system storage objects,
change table body tag to htbody as per EM change to DTD,
add rule about space normalization in public identifiers,
add description of how to generate our name-space rules from 
Unicode character database (needs further work!).
</sitem>
<sitem>1997-10-08 : TB : Removed %-constructs again, new rules
for PE appearance.</sitem>
<sitem>1997-10-01 : TB : Case-sensitive markup; cleaned up
element-type defs, lotsa little edits for style</sitem>
<sitem>1997-09-25 : TB : Change to elm's new DTD, with
substantial detail cleanup as a side-effect</sitem>
<sitem>1997-07-24 : CMSMcQ : correct error (lost *) in definition 
of ignoreSectContents (thanks to Makoto Murata)</sitem>
<sitem>Allow all empty elements to have end-tags, consistent with
SGML TC (as per JJC).</sitem>
<sitem>1997-07-23 : CMSMcQ : pre-emptive strike on pending corrections:
introduce the term 'empty-element tag', note that all empty elements
may use it, and elements declared EMPTY must use it.
Add WFC requiring encoding decl to come first in an entity.
Redefine notations to point to PIs as well as binary entities.
Change autodetection table by removing bytes 3 and 4 from 
examples with Byte Order Mark.
Add content model as a term and clarify that it applies to both
mixed and element content.
</sitem>
<sitem>1997-06-30 : CMSMcQ : change date, some cosmetic changes,
changes to productions for choice, seq, Mixed, NotationType,
Enumeration.  Follow James Clark's suggestion and prohibit 
conditional sections in internal subset.  TO DO:  simplify
production for ignored sections as a result, since we don't 
need to worry about parsers which don't expand PErefs finding
a conditional section.</sitem>
<sitem>1997-06-29 : TB : various edits</sitem>
<sitem>1997-06-29 : CMSMcQ : further changes:
Suppress old FINAL EDIT comments and some dead material.
Revise occurrences of % in grammar to exploit Henry Thompson's pun,
especially markupdecl and attdef.
Remove RMD requirement relating to element content (?).
</sitem>
<sitem>1997-06-28 : CMSMcQ : Various changes for 1 July draft:
Add text for draconian error handling (introduce
the term Fatal Error).
RE deleta est (changing wording from 
original announcement to restrict the requirement to validating
parsers).
Tag definition of validating processor and link to it.
Add colon as name character.
Change def of %operator.
Change standard definitions of lt, gt, amp.
Strip leading zeros from #x00nn forms.</sitem>
<sitem>1997-04-02 : CMSMcQ : final corrections of editorial errors
found in last night's proofreading.  Reverse course once more on
well-formed:   Webster's Second hyphenates it, and that's enough
for me.</sitem>
<sitem>1997-04-01 : CMSMcQ : corrections from JJC, EM, HT, and self</sitem>
<sitem>1997-03-31 : Tim Bray : many changes</sitem>
<sitem>1997-03-29 : CMSMcQ : some Henry Thompson (on entity handling),
some Charles Goldfarb, some ERB decisions (PE handling in miscellaneous
declarations.  Changed Ident element to accept def attribute.
Allow normalization of Unicode characters.  move def of systemliteral
into section on literals.</sitem>
<sitem>1997-03-28 : CMSMcQ : make as many corrections as possible, from
Terry Allen, Norbert Mikula, James Clark, Jon Bosak, Henry Thompson,
Paul Grosso, and self.  Among other things:  give in on "well formed"
(Terry is right), tentatively rename QuotedCData as AttValue
and Literal as EntityValue to be more informative, since attribute
values are the <emph>only</emph> place QuotedCData was used, and
vice versa for entity text and Literal. (I'd call it Entity Text, 
but 8879 uses that name for both internal and external entities.)</sitem>
<sitem>1997-03-26 : CMSMcQ : resynch the two forks of this draft, reapply
my changes dated 03-20 and 03-21.  Normalize old 'may not' to 'must not'
except in the one case where it meant 'may or may not'.</sitem>
<sitem>1997-03-21 : TB : massive changes on plane flight from Chicago
to Vancouver</sitem>
<sitem>1997-03-21 : CMSMcQ : correct as many reported errors as possible.
</sitem>
<sitem>1997-03-20 : CMSMcQ : correct typos listed in CMSMcQ hand copy of spec.</sitem>
<sitem>1997-03-20 : CMSMcQ : cosmetic changes preparatory to revision for
WWW conference April 1997:  restore some of the internal entity 
references (e.g. to docdate, etc.), change character xA0 to &amp;nbsp;
and define nbsp as &amp;#160;, and refill a lot of paragraphs for
legibility.</sitem>
<sitem>1996-11-12 : CMSMcQ : revise using Tim's edits:
Add list type of NUMBERED and change most lists either to
BULLETS or to NUMBERED.
Suppress QuotedNames, Names (not used).
Correct trivial-grammar doc type decl.
Rename 'marked section' as 'CDATA section' passim.
Also edits from James Clark:
Define the set of characters from which [^abc] subtracts.
Charref should use just [0-9] not Digit.
Location info needs cleaner treatment:  remove?  (ERB
question).
One example of a PI has wrong pic.
Clarify discussion of encoding names.
Encoding failure should lead to unspecified results; don't
prescribe error recovery.
Don't require exposure of entity boundaries.
Ignore white space in element content.
Reserve entity names of the form u-NNNN.
Clarify relative URLs.
And some of my own:
Correct productions for content model:  model cannot
consist of a name, so "elements ::= cp" is no good.
</sitem>
<sitem>1996-11-11 : CMSMcQ : revise for style.
Add new rhs to entity declaration, for parameter entities.</sitem>
<sitem>1996-11-10 : CMSMcQ : revise for style.
Fix / complete section on names, characters.
Add sections on parameter entities, conditional sections.
Still to do:  Add compatibility note on deterministic content models.
Finish stylistic revision.</sitem>
<sitem>1996-10-31 : TB : Add Entity Handling section</sitem>
<sitem>1996-10-30 : TB : Clean up term &amp; termdef.  Slip in
ERB decision re EMPTY.</sitem>
<sitem>1996-10-28 : TB : Change DTD.  Implement some of Michael's
suggestions.  Change comments back to //.  Introduce language for
XML namespace reservation.  Add section on white-space handling.
Lots more cleanup.</sitem>
<sitem>1996-10-24 : CMSMcQ : quick tweaks, implement some ERB
decisions.  Characters are not integers.  Comments are /* */ not //.
Add bibliographic refs to 10646, HyTime, Unicode.
Rename old Cdata as MsData since it's <emph>only</emph> seen
in marked sections.  Call them attribute-value pairs not
name-value pairs, except once.  Internal subset is optional, needs
'?'.  Implied attributes should be signaled to the app, not
have values supplied by processor.</sitem>
<sitem>1996-10-16 : TB : track down &amp; excise all DSD references;
introduce some EBNF for entity declarations.</sitem>
<sitem>1996-10-?? : TB : consistency check, fix up scraps so
they all parse, get formatter working, correct a few productions.</sitem>
<sitem>1996-10-10/11 : CMSMcQ : various maintenance, stylistic, and
organizational changes:
Replace a few literals with xmlpio and
pic entities, to make them consistent and ensure we can change pic
reliably when the ERB votes.
Drop paragraph on recognizers from notation section.
Add match, exact match to terminology.
Move old 2.2 XML Processors and Apps into intro.
Mention comments, PIs, and marked sections in discussion of
delimiter escaping.
Streamline discussion of doctype decl syntax.
Drop old section of 'PI syntax' for doctype decl, and add
section on partial-DTD summary PIs to end of Logical Structures
section.
Revise DSD syntax section to use Tim's subset-in-a-PI
mechanism.</sitem>
<sitem>1996-10-10 : TB : eliminate name recognizers (and more?)</sitem>
<sitem>1996-10-09 : CMSMcQ : revise for style, consistency through 2.3
(Characters)</sitem>
<sitem>1996-10-09 : CMSMcQ : re-unite everything for convenience,
at least temporarily, and revise quickly</sitem>
<sitem>1996-10-08 : TB : first major homogenization pass</sitem>
<sitem>1996-10-08 : TB : turn "current" attribute on div type into 
CDATA</sitem>
<sitem>1996-10-02 : TB : remould into skeleton + entities</sitem>
<sitem>1996-09-30 : CMSMcQ : add a few more sections prior to exchange
                            with Tim.</sitem>
<sitem>1996-09-20 : CMSMcQ : finish transcribing notes.</sitem>
<sitem>1996-09-19 : CMSMcQ : begin transcribing notes for draft.</sitem>
<sitem>1996-09-13 : CMSMcQ : made outline from notes of 09-06,
do some housekeeping</sitem>
</slist>
</revisiondesc>
</header>
<body> 
<div1 id="sec-intro">
<head>一般事項</head>
<!--	    <div2 id='sec-scope'>
	      <head>適用範囲</head> -->
<p>拡張可能なマーク付け言語XML(eXtensible Markup Language)は，<termref def="dt-xml-doc">XML文書</termref>というデータオブジェクトのクラスを規定し，XML文書を処理するプログラムの動作の一部を規定する。XMLは，SGML(標準一般化マーク付け言語，Standard Generalized Markup Language)<bibref ref="ISO8879"/>の制限したサブセットとする。構造上，XML文書は，かならずSGML規格に適合する。</p>
<p>XML文書は，<termref def="dt-entity">実体</termref>という記憶単位からなり，実体は，解析されるデータ又は解析されないデータからなる。解析されるデータは，<termref def="dt-character">文字</termref>からなり，その一部は，文書の<termref def="dt-chardata">文字データ</termref>を構成し，一部は，<termref def="dt-markup">マーク付け</termref>を構成する。マーク付けは，文書の記憶レイアウト及び論理構造についての記述を表す符号とする。XMLは，記憶レイアウト及び論理構造についての制約条件を記述する機構を提供する。</p>
<p><termdef id="dt-xml-proc" term="XMLプロセサ"><term>XMLプロセサ</term>というソフトウェアモジュールは，XML文書を読み込み，その内容及び構造へのアクセスを提供するために用いる。 </termdef> <termdef id="dt-app" term="アプリケーション">XMLプロセサは，他のモジュールのために動作することを前提とし，そのモジュールを<term>アプリケーション</term>という。</termdef>この仕様書は，XMLプロセサが行わなければならない振舞いを規定する。つまり，XMLデータの読込み方法を規定し，アプリケーションに提供する情報を規定する。</p>
<!--	    </div2> -->
<div2 id="sec-origin-goals">
<head>経緯及び目標</head>
<p>1996年にWorld Wide Web Consortium(W3C)の中に設立したXML作業グループ(以前は， SGML編集レビュー委員会と呼ばれた)が，XMLを開発した。この作業グループの議長を，Sun MicrosystemsのJon Bosakが勤める。W3Cが組織し，以前はSGML作業グループと呼ばれたXML SIG(Special Interest Group)も，XMLの制定に非常に活発に参画した。
<!--JISでは? XML作業グループのメンバを付録に示す。-->Dan Connollyは，作業グループのW3Cにおける連絡係を務めた。</p>
<p>XMLの設計目標を，次に示す。<ulist>
<item><p>a) XMLは，Internet上でそのまま使用できる。</p></item>
<item><p>b) XMLは，広範囲のアプリケーションを支援する。</p></item>
<item><p>c) XMLは，SGMLと互換性をもつ。</p></item>
<item><p>d) XML文書を処理するプログラムを書くことは，容易でなければならない。</p></item>
<item><p>e) XMLでは，オプションの機能はできるだけ少なくし，一つも存在しないことを目指す。</p></item>
<item><p>f) XML文書は，人間にとって読みやすく，十分に理解しやすい。</p></item>
<item><p>g) XMLの設計は，すみやかに行えなければならない。</p></item>
<item><p>h) XMLの設計は，厳密及び簡潔でなければならない。</p></item>
<item><p>i) XML文書は，容易に作成できる。</p></item>
<item><p>j) XMLでは，マーク付けの数を減らすことは，重要ではない。</p></item></ulist>
</p>
<p>XML第1.0版を理解し，それを処理する計算機プログラムを書くために十分な情報は，この仕様書及び関連する規格(文字用として，Unicode及びISO/IEC 10646，<!--* XXX for Uniform Resource Identifiers, *-->言語識別タグ用として，インタネット RFC 1766，言語コード用として，ISO 639，並びに国コード用として，ISO 3166)で，すべて示す。</p>
<p>この版のXMLの規定<!-- (&doc.date;) -->は，公開レビュー及び議論を目的とする。テキスト及び法律上の注意を改変しない限り，自由に配布してもよい。</p>
</div2>
<div2 id="sec-terminology">
<head>定義</head>
<p>XML文書の規定のために使用する用語は，この仕様書内で定義する。次に示す語句は，それらの用語を定義するため，及びXMLプロセサの動きを規定するために使用する。
<glist>
<gitem>
<label>1.2.1 してもよい(may)</label>
<def><p><termdef id="dt-may" term="してもよい">適合する文書又はXMLプロセサは，記述されたとおりに動作してもよいが，そのとおりにする必要はない。</termdef></p></def>
</gitem>
<gitem>
<label>1.2.2 しなければならない(must)</label>
<def><p>適合する文書又はXMLプロセサは，記述されたとおりに動作することが要求される。そうでなければ，エラーとする。<!-- do NOT change this! this is what defines a violation ofa 'must' clause as 'an error'. -MSM -->
</p></def>
</gitem>
<gitem>
<label>1.2.3 エラー(error)</label>
<def><p><termdef id="dt-error" term="エラー">この仕様書が定める規則に対する違反。結果は定義しない。適合するソフトウェアは，エラーを検出して報告してもよく，エラーから回復してもよい。</termdef></p></def>
</gitem>
<gitem>
<label>1.2.4 致命的エラー(fatal error)</label>
<def><p><termdef id="dt-fatal" term="致命的エラー">適合する<termref def="dt-xml-proc">XMLプロセサ</termref>が検出しなければならず，アプリケーションに報告しなければならないエラー。致命的エラーを発見したあと，プロセサは，それ以降のエラーを探すためにデータ処理を続行してもよく，エラーを発見した場合は，そのエラーをアプリケーションに報告してもよい。エラー訂正をサポートするために，プロセサは，未処理データ(文字データ及びマーク付けの混在したもの)を文書から取り出し，アプリケーションに渡してもよい。しかし，一度，致命的エラーを検出したら，プロセサは，通常の処理を続行してはならない。つまり，プロセサは，文字データ及び文書の論理構造についての情報を，通常の方法でアプリケーションに渡し続けてはならない。</termdef></p></def>
</gitem>
<gitem>
<label>1.2.5 ユーザのオプション指定によっては(at user option)</label>
<def><p>適合するソフトウエアは，記述されたとおりに振る舞ってもよい(may)，又は振る舞わなくてはならない(must)(文章中の助動詞による。)。そのとおりに振る舞う場合は，記述された振舞いを選択又は拒否する手段をユーザに提供しなければならない。</p></def>
</gitem>
<gitem>
<label>1.2.6 妥当性制約(validity constraint)</label>
<def><p>すべての<termref def="dt-valid">妥当な</termref>XML文書に適用する規則。妥当性制約の違反は，エラーとする。ユーザのオプション指定によっては，<termref def="dt-validating">検証を行うXMLプロセサ</termref>は，このエラーを報告しなければならない。</p></def>
</gitem>
<gitem>
<label>1.2.7 整形式制約(well-formedness constraint)</label>
<def><p>すべての<termref def="dt-wellformed">整形式</termref>のXML文書に適用する規則。整形式制約の違反は，<termref def="dt-fatal">致命的エラー</termref>とする。</p></def>
</gitem>
<gitem>
<label>1.2.8 マッチ(match)</label>
<def><p>a) <termdef id="dt-match" term="マッチ">文字列又は名前のマッチ　比較する二つの文字列又は名前は，同一でなければならない。ISO/IEC 10646において，複数の表現が可能な文字［例えば，合成形式及び基底+発音符(ダイアクリティカルマーク)形式］は，どちらの文字列も同じ表現のときに限り，マッチする。ユーザのオプション指定によっては，プロセサは，その文字を標準形に正規化してもよい。比較のとき、大文字と小文字との区別をする。<!-- Note that no processing of characters with respect to case is part of the matching process. -->&lt;BR&gt;b) 文字列と文法中の規則とのマッチ　ある生成規則から生成する言語に，ある文字列が属するとき，この文字列は，この生成規則にマッチするという。&lt;BR&gt;c) 内容と内容モデルとのマッチ　ある要素が，<titleref href="elementvalid">要素の妥当性</titleref>の制約に示す意味で適合するとき，この要素は，その宣言にマッチするという。</termdef></p></def>
</gitem>
<gitem>
<label>1.2.9 互換性のため(for compatibility)</label>
<def><p><termdef id="dt-compat" term="互換性のため">XMLの機能であって，XMLがSGMLと互換であることを保証するためだけに導入されるもの。</termdef></p></def>
</gitem>
<gitem>
<label>1.2.10 相互運用性のため(for interoperability)</label>
<def><p><termdef id="dt-interop" term="相互運用性のため">拘束力はもたない推奨事項。ISO 8879へのWebSGML適用附属書以前から存在するSGMLプロセサが，XML文書を処理できる可能性を高めるために取り入れるもの。</termdef></p></def>
</gitem>
</glist>
</p>
</div2>
</div1>
<!-- &Docs; -->
<div1 id="sec-documents">
<head>文書</head>
<p><termdef id="dt-xml-doc" term="XML文書">
<!-- A textual object -->
この仕様書で定義する意味で，<termref def="dt-wellformed">整形式</termref>とするデータオブジェクトを，<term>XML文書</term>という。整形式のXML文書が，さらに，ある制約条件を満足すれば，<termref def="dt-valid">妥当</termref>なXML文書とする。
</termdef></p>

<!-- why this div? -TB
<div2 id='sec-log-phys'> 
<head>Logical and Physical Structure</head> -->

<p>いずれのXML文書も，論理構造及び物理構造をもつ。物理的には，文書は，<termref def="dt-entity">実体</termref>と呼ぶ単位からなる。ある実体は，文書内に他の実体を含むために，その他の実体を<termref def="dt-entref">参照</termref>してもよい。文書は，“ルート”すなわち<termref def="dt-docent">文書実体</termref>から始まる。論理的には，文書は，宣言，要素，コメント，文字参照及び処理命令を含み，これらすべては，文書内で明示的なマーク付けによって示す。論理構造及び物理構造は，<titleref href="wf-entities">以降</titleref>に示すとおりに，厳密に入れ子になっていなければならない。</p>

<!-- 
</div2> -->

<div2 id="sec-well-formed">
<head>整形式のXML文書</head>
<p><termdef id="dt-wellformed" term="整形式">あるテキストオブジェクトが，次のいずれかのとき，そのテキストオブジェクトを整形式のXML文書と呼ぶ。</termdef>
<ulist>
<item><p>a) 全体として，<nt def="NT-document">document</nt>というラベルをもつ生成規則にマッチする。</p></item>
<item><p>b) この仕様書で定義する，すべての整形式制約に従う。</p>
</item>
<item><p>c) それぞれの<termref def="dt-parsedent">解析対象実体</termref>が，<titleref href="wf-entities">整形式</titleref>となる。</p></item>
</ulist></p>
<p>
<scrap lang="ebnf" id="document">
<head>文書</head>
<prod id="NT-document"><lhs>document</lhs>
<rhs><nt def="NT-prolog">prolog</nt> 
<nt def="NT-element">element</nt> 
<nt def="NT-Misc">Misc</nt>*</rhs></prod>
</scrap>
</p>
<p><nt def="NT-document">document</nt>生成規則にマッチするとは，次を意味する。
<ulist>
<item><p>a) 一つ以上の<termref def="dt-element">要素</termref>を含む。</p>
</item>

<!--* N.B. some readers (notably JC) find the following
paragraph awkward and redundant.  I agree it's logically redundant:
it *says* it is summarizing the logical implications of
matching the grammar, and that means by definition it's
logically redundant.  I don't think it's rhetorically
redundant or unnecessary, though, so I'm keeping it.  It
could however use some recasting when the editors are feeling
stronger. -MSM *-->

<item><p>b) <termdef id="dt-root" term="ルート要素"><term>ルート</term>又は文書要素という要素が一つだけ存在し，これは，他の要素の<termref def="dt-content">内容</termref>に含まれない。</termdef>これ以外のすべての要素は，その開始タグが他の要素の内容に含まれれば，対応する終了タグも同じ要素の内容に含まれる。つまり，要素は，開始タグ及び終了タグによって区切られ，入れ子構造をなす。
</p></item>
</ulist>
</p>
<p><termdef id="dt-parentchild" term="親要素/子要素">これらの結果として，文書内のどの非ルート要素<code>C</code>に対しても，ある他の要素<code>P</code>が存在し，<code>C</code>は，<code>P</code>の内容に含まれるが，<code>P</code>の内容に含まれる他の要素に含まれることはない。このとき，<code>P</code>を<code>C</code>の<code>親</code>といい，<code>C</code>を<code>P</code>の<code>子</code>という。</termdef></p>
</div2>
<div2 id="charsets">
<head>文字</head>
<p>

<!--The data stored in an XML <termref def="dt-entity">entity</termref> is
either <termref def="dt-text">parsed</termref> or <termref
def="dt-unparsed">unparsed</termref>. -->

<termdef id="dt-text" term="テキスト">解析対象実体は，<term>テキスト</term>(<termref def="dt-character">文字</termref>の並びであって，マーク付け又は文字データを表してもよい。)を含む。</termdef><termdef id="dt-character" term="文字"><term>文字</term>は，テキストの最小単位であって，ISO/IEC 10646<bibref ref="ISO10646"/>に規定される。<!--Users may extend the ISO/IEC 10646 character repertoire by exploiting the private use areas. -->許容する文字は，タブ，改行，復帰並びにUnicode及びISO/IEC 10646が許容する図形文字とする。</termdef> 
<scrap lang="ebnf" id="char32">
<head>文字の範囲</head>
<prodgroup pcw2="4" pcw4="17.5" pcw5="11">
<prod id="NT-Char"><lhs>Char</lhs> 
<rhs>#x9 | #xA | #xD | [#x20-#D7FF] | [#xE000-#xFFFD] 
| [#x10000-#x10FFFF]</rhs> 
<com>任意のUnicode文字。ただし，サロゲートブロック，FFFE及びFFFFは除く。</com>
</prod>
</prodgroup>
</scrap>
</p>
<p>文字番号をビットパタンに符号化する機構は，実体ごとに違ってもよい。すべてのXMLプロセサは，ISO/IEC 10646のUTF-8符号化及びUTF-16符号化を受け付けなければならない。二つのどちらが用いられているかを明示するための機構，及び他の符号化方法を利用するための機構は，<titleref href="charencoding">文字の符号化</titleref>に記述する。</p>
<p>どの符号化方法を用いるかに関係なく，ISO/IEC 10646の文字集合にあるすべての文字は，そのUCS-4コード値<!-- bit string. -->と等価な10進数又は16進数によって，参照できる。</p>
</div2>

<div2 id="sec-common-syn">
<head>共通の構文構成子</head>
 
<p>2.3では，文法内で広く使用するいくつかの記号を定義する。</p>
<p><nt def="NT-S">S</nt> (空白)は，一つ若しくは複数のスペース文字(#x20)，復帰，改行又はタブから成る。

<scrap lang="ebnf" id="white">
<head>空白</head>
<prodgroup pcw2="4" pcw4="17.5" pcw5="11">
<prod id="NT-S"><lhs>S</lhs>
<rhs>(#x20 | #x9 | #xD | #xA)+</rhs>
</prod>
</prodgroup>
</scrap></p>
<p>便宜上，文字を，字，数字又は他の文字に分類する。字は，アルファベット的又は表音的である基本文字(一つ又は複数の結合文字が，後に続くこともある。)，統合漢字から成る。
<!-- 
Certain layout and format-control characters defined by ISO/IEC 10646 
should be ignored when recognizing identifiers; these are defined by the 
classes <nt def='NT-Ignorable'>Ignorable</nt> and <nt def='NT-
Extender'>Extender</nt>. 
-->
各クラスにおける実際の文字についての完全な定義は，<titleref href="CharClasses">文字クラス</titleref>に関する付録に規定する。</p>
<p><termdef id="dt-name" term="Name"><term>Name</term>は，字又はいくつかの区切り文字の一つで始まり，その後に字，数字，ハイフン，下線，コロン又はピリオドが続く(これらを名前文字という。)。</termdef>文字列"<code>xml</code>"又は<code>(('X'|'x') ('M'|'m') ('L'|'l'))</code>にマッチする任意の文字列で始まる名前は，この仕様書の現在の版又は将来の版での標準化のために予約する。
</p>
<note>
<p>XMLの名前の中のコロンは，名前空間での実験のために予約する。コロンの意味は，将来のある時点で標準化するものとし，そのときには，実験的な目的でコロンを使用する文書を更新する必要が生じる可能性がある。XMLで採用する名前空間の機構が，区切り子として実際にコロンを使用するという保証はない。事実上，これは，名前空間の実験の一つとして以外には，XMLの名前の中でコロンを使用しないほうがよいことを意味する。しかし，XMLプロセサは，名前文字としてコロンを受け付けることが望ましい。
</p>
</note>
<p>
<nt def="NT-Nmtoken">Nmtoken</nt> (名前トークン)は，名前文字で構成する列とする。
<scrap lang="ebnf">
<head>名前及びトークン</head>
<!--
<prod id='NT-MiscName'><lhs>MiscName</lhs>
<rhs></rhs>
</prod>-->
<prod id="NT-NameChar"><lhs>NameChar</lhs>
<rhs><nt def="NT-Letter">Letter</nt> 
| <nt def="NT-Digit">Digit</nt> 
<!--| <nt def='NT-MiscName'>MiscName</nt>-->
| '.' | '-' | '_' | ':'
| <nt def="NT-CombiningChar">CombiningChar</nt> 
<!-- | <nt def='NT-Ignorable'>Ignorable</nt>  -->
| <nt def="NT-Extender">Extender</nt></rhs>
</prod>
<prod id="NT-Name"><lhs>Name</lhs>
<rhs>(<nt def="NT-Letter">Letter</nt> | '_' | ':')
(<nt def="NT-NameChar">NameChar</nt>)*</rhs></prod>
<prod id="NT-Names"><lhs>Names</lhs>
<rhs><nt def="NT-Name">Name</nt> 
(<nt def="NT-S">S</nt> <nt def="NT-Name">Name</nt>)*</rhs></prod>
<prod id="NT-Nmtoken"><lhs>Nmtoken</lhs>
<rhs>(<nt def="NT-NameChar">NameChar</nt>)+</rhs></prod>
<prod id="NT-Nmtokens"><lhs>Nmtokens</lhs>
<rhs><nt def="NT-Nmtoken">Nmtoken</nt> (<nt def="NT-S">S</nt> <nt def="NT-Nmtoken">Nmtoken</nt>)*</rhs></prod>
</scrap>
</p>
<p>リテラルデータは，引用符で囲まれた文字列とし，その列の区切り子として使用する引用符は含まない。リテラルは，内部実体(<nt def="NT-EntityValue">EntityValue</nt>)，属性値(<nt def="NT-AttValue">AttValue</nt>)，外部識別子(<nt def="NT-SystemLiteral">SystemLiteral</nt>)の内容の指定に使用する。目的によっては，リテラル全体を，その中のマーク付けの走査を行なわずに，スキップすることがある(<nt def="NT-SkipLit">SkipLit</nt>。)。
<scrap lang="ebnf">
<head>リテラル</head>
<!-- is marked section end legal in entity values etc.?
James says yes.  Handbook page 392, sec. 10.4 seems to me to say no. 
If James is right, leave as is.  Otherwise, uncomment
the next comment and ... 
-->
<!--
<prod id='NT-EntityValue'><lhs>EntityValue</lhs>
<rhs>' " ' 
(([^%&amp;"] 
| <nt def='NT-PEReference'>PEReference</nt> 
| <nt def='NT-Reference'>Reference</nt>)*
- (<nt def='NT-Char'>Char</nt>* ']]&gt;' <nt def='NT-char'>Char</nt>*))
' " ' 
</rhs>
<rhs>|&nbsp; 
" ' " 
(([^%&amp;'] 
| <nt def='NT-PEReference'>PEReference</nt> 
| <nt def='NT-Reference'>Reference</nt>)* 
- (<nt def='NT-Char'>Char</nt>* ']]&gt;' <nt def='NT-char'>Char</nt>*))
" ' "</rhs>
</prod>
<prod id='NT-AttValue'><lhs>AttValue</lhs>
<rhs>'"' 
(([^&lt;&amp;"] 
| <nt def='NT-Reference'>Reference</nt>)* 
- (<nt def='NT-Char'>Char</nt>* ']]&gt;' <nt def='NT-char'>Char</nt>*))
' " ' 
</rhs>
<rhs>|&nbsp; 
" ' " 
(([^&lt;&amp;'] 
| <nt def='NT-Reference'>Reference</nt>)* 
- (<nt def='NT-Char'>Char</nt>* ']]&gt;' <nt def='NT-char'>Char</nt>*))
" ' "</rhs>
<wfc def="CleanAttrVals"/>
</prod>
-->
<!-- ... and comment out the following, down to ... -->
<prod id="NT-EntityValue"><lhs>EntityValue</lhs>
<rhs>' " ' 
([^%&amp;"] 
| <nt def="NT-PEReference">PEReference</nt> 
| <nt def="NT-Reference">Reference</nt>)*
' " ' 
</rhs>
<rhs>|&#160; 
" ' " 
([^%&amp;'] 
| <nt def="NT-PEReference">PEReference</nt> 
| <nt def="NT-Reference">Reference</nt>)* 
" ' "</rhs>
</prod>
<prod id="NT-AttValue"><lhs>AttValue</lhs>
<rhs>' " ' 
([^&lt;&amp;"] 
| <nt def="NT-Reference">Reference</nt>)* 
' " ' 
</rhs>
<rhs>|&#160; 
" ' " 
([^&lt;&amp;'] 
| <nt def="NT-Reference">Reference</nt>)* 
" ' "</rhs>
<!--<wfc def="WF-Attvaldelim"/>-->
</prod>
<!-- ... down to here. -->
<prod id="NT-SystemLiteral"><lhs>SystemLiteral</lhs>
<rhs><nt def="NT-SkipLit">SkipLit</nt></rhs>
</prod>
<!-- <prod id="NT-URIchar"><lhs>URIchar</lhs>
<rhs><com>See <loc href="http://www.w3.org/XXX">XXX</loc></com>
</rhs></prod>
-->
<prod id="NT-PubidLiteral"><lhs>PubidLiteral</lhs>
<rhs>' " ' <nt def="NT-PubidChar">PubidChar</nt>* 
' " ' 
| " ' " (<nt def="NT-PubidChar">PubidChar</nt> - " ' ")* " ' "</rhs>
</prod>
<prod id="NT-PubidChar"><lhs>PubidChar</lhs>
<rhs>#x20 | #xD | #xA 
|&#160;[a-zA-Z0-9]
|&#160;[-'()+,./:=?]</rhs>
</prod>
<prod id="NT-SkipLit"><lhs>SkipLit</lhs>
<rhs>(' " ' [^"]* ' " ') 
|&#160;(" ' " [^']* " ' ")</rhs>
</prod>
<!-- alternate form, making ms end illegal: -->
<!-- 
<prod id="NT-SkipLit"><lhs>SkipLit</lhs>
<rhs>(' " ' ([^"]* - ([^"]* ']]&gt;' [^"]*)) ' " ') 
|&nbsp;(" ' " ([^']* - ([^']* ']]&gt;' [^']*)) " ' ")</rhs>
</prod>
-->
</scrap>
</p>
<!--
<wfcnote id="WF-Attvaldelim">
<head>Delimiters in Attribute Values</head>
<p>After the expansion of character and entity references,
an attribute value must not contain a "<code>&lt;</code>" 
or "<code>&amp;</code>" character unless that character was 
introduced by the expansion of a character reference 
or one of the entities &magicents;.</p>
</wfcnote>-->
<!--
This is not quite right:  &lt; should be legal, should it not?
Suppress this WFC until we get it right.
-->
<!-- Henry Thompson suggests (in substance, not form: the wording needs
to be clarified):
"Cooked Attribute values must not contain &lt; &amp; or the
quote which closed their uncooked literal,
unless arising from the expansion of a character reference or
magic reference
directly contained in their uncooked literal."
I'm not sure I agree with this rule, but it's at least coherent,
which is more than I can say for my attempt.
-->
</div2>

<div2 id="syntax">
<head>文字データ及びマーク付け</head>
<p><termref def="dt-text">テキスト</termref>は，<termref def="dt-chardata">文字データ</termref>及びマーク付けが混在するものとして構成する。<termdef id="dt-markup" term="Markup"><term>マーク付け</term>は，<termref def="dt-stag">開始タグ</termref>，<termref def="dt-etag">終了タグ</termref>，<termref def="dt-empty">空要素</termref>，<termref def="dt-entref">実体参照</termref>，<termref def="dt-charref">文字参照</termref>，<termref def="dt-comment">コメント</termref>，<termref def="dt-cdsection">CDATAセクション</termref> の区切り子，<termref def="dt-doctype">文書型宣言</termref>及び<termref def="dt-pi">処理命令</termref>の形を取る。
</termdef>
</p>
<p><termdef id="dt-chardata" term="Character Data">マーク付けではないすべてのテキストは，文書の<term>文字データ</term>を構成する。</termdef></p>
<p>アンパサンド文字 (&amp;)及び不等号(小なり) (&lt;)は，マーク付けの区切り子として，又は<termref def="dt-comment">コメント</termref>，<termref def="dt-pi">処理命令</termref>若しくは<termref def="dt-cdsection">CDATAセクション</termref>内で使用する場合に<emph>だけ</emph>，そのままの形で出現してよい。これらの文字は，内部実体宣言の<termref def="dt-litentval">リテラル実体値</termref>内に記述してもよい。 詳しくは，<titleref href="wf-entities">整形式の実体</titleref>に関する規定を参照。<!-- FINAL EDIT:  restore internal entity decl or leave it out. -->これらの文字が他の部分で必要な場合，数値による文字参照又は文字列"<code>&amp;amp;</code>"及び文字列"<code>&amp;lt;</code>"を使用し，<termref def="dt-escape">別扱い</termref>しなければならない。不等号(大なり) (&gt;) は，文字列"<code>&amp;gt;</code>"を使用して表現してもよい。内容の中で列"<code>]]&gt;</code>"を使用するときは，それが，<termref def="dt-cdsection">CDATAセクション</termref>の終了をマーク付けしない限り，<termref def="dt-compat">互換性のため</termref>，"<code>&amp;gt;</code>"又は文字参照を使用し，別扱いしなければならない。</p>

<p>要素の内容では，文字データは，いかなるマーク付けの開始区切り子を含まない任意の文字列とする。CDATAセクションでは，文字データとは，CDATAセクションの終了区切り子"<code>]]&gt;</code>"を含まない任意の文字列とする。
</p>
<p>
属性値に一重引用符及び二重引用符を含むためには，アポストロフィ又は一重引用符(') は，"<code>&amp;apos;</code>"として表現し，二重引用符(")は，"<code>&amp;quot;</code>"として表現する。
<scrap lang="ebnf">
<head>文字データ</head>
<prod id="NT-CharData">
<lhs>CharData</lhs>
<rhs>[^&lt;&amp;]* - ([^&lt;&amp;]* ']]&gt;' [^&lt;&amp;]*)</rhs>
</prod>
</scrap>
</p>
</div2>
 
<div2 id="sec-comments">
<head>コメント</head>
 
<p><termdef id="dt-comment" term="Comment"><term>コメント</term>は，他の<termref def="dt-markup">マーク付け</termref>の外ならば，文書のどこに現れてもよい。さらに，文書型宣言内で，文法が許す場所に現れてもよい。
<!-- TB
except in a <termref def="dt-cdsection">CDATA section</termref>, i.e. within
<termref def="dt-elemcontent">element content</termref>, in 
<termref def="dt-mixed">mixed content</termref>, or in the prolog.  They must
not occur within declarations or tags. -->
コメントは，文書の<termref def="dt-chardata">文字データ</termref>の一部ではない。XMLプロセサは，アプリケーションがコメントのテキストを取り出すことを可能としてもよいが，そうしなくともよい。
<termref def="dt-compat">互換性のため</termref>，文字列"<code>--</code>" （二連ハイフン）は，コメント内で現れてはならない。
<scrap lang="ebnf">
<head>コメント</head>
<prod id="NT-Comment"><lhs>Comment</lhs>
<rhs>'&lt;!--'
((<nt def="NT-Char">Char</nt> - '-') 
| ('-' (<nt def="NT-Char">Char</nt> - '-')))* 
'--&gt;'</rhs>
<!--
<rhs>'&lt;!&como;' 
(<nt def='NT-Char'>Char</nt>* - 
(<nt def='NT-Char'>Char</nt>* '&comc;' <nt def='NT-Char'>Char</nt>*)) 
'&comc;&gt;'</rhs> -->
</prod>
</scrap>
</termdef></p>
<p>コメントの例を次に示す。
<eg>&lt;!-- declarations for &lt;head&gt; &amp; &lt;body&gt; --&gt;</eg>
</p>
</div2>

<div2 id="sec-pi">
<head>処理命令</head>
 
<p><termdef id="dt-pi" term="Processing instruction"><term>処理命令</term>(PI)によって，アプリケーションのための命令を文書に入れることができる。
 
<scrap lang="ebnf">
<head>処理命令</head>
<prod id="NT-PI"><lhs>PI</lhs>
<rhs>'&lt;?' <nt def="NT-PITarget">PITarget</nt> 
(<nt def="NT-S">S</nt> 
(<nt def="NT-Char">Char</nt>* - 
(<nt def="NT-Char">Char</nt>* '?&gt;' <nt def="NT-Char">Char</nt>*)))?
'?&gt;'</rhs></prod>
<prod id="NT-PITarget"><lhs>PITarget</lhs>
<rhs><nt def="NT-Name">Name</nt> - 
(('X' | 'x') ('M' | 'm') ('L' | 'l'))</rhs>
</prod>
</scrap></termdef>
PIは，文書の<termref def="dt-chardata">文字データ</termref>の一部ではないが，アプリケーションに渡されなければならない。PIは，命令が渡されるアプリケーションを特定するために使用するターゲット (<nt def="NT-PITarget">PITarget</nt>) で始まる。ターゲット名 "<code>XML</code>"，"<code>xml</code>"などは，この仕様書の現在の版又は将来の版の規格化用に予約する。XMLの<termref def="dt-notation">記法</termref>機構を，PIのターゲットを宣言するために使用してもよい。
</p>
</div2>
 
<div2 id="sec-cdata-sect">
<head>CDATAセクション</head>
 
<p><termdef id="dt-cdsection" term="CDATA Section"><term>CDATAセクション</term>は，文字データが出現するところであれば，どこに出現してもよい。これは，そうでなければ，マーク付けとして認識する文字を含む，テキストの区画を別扱いするのに使用する。CDATAセクションは，文字列"<code>&lt;![CDATA[</code>"で始まり，文字列
"<code>]]&gt;</code>"で終わる。
<scrap lang="ebnf">
<head>CDATAセクション</head>
<prod id="NT-CDSect"><lhs>CDSect</lhs>
<rhs><nt def="NT-CDStart">CDStart</nt> 
<nt def="NT-CData">CData</nt> 
<nt def="NT-CDEnd">CDEnd</nt></rhs></prod>
<prod id="NT-CDStart"><lhs>CDStart</lhs>
<rhs>'&lt;![CDATA['</rhs>
</prod>
<prod id="NT-CData"><lhs>CData</lhs>

<rhs>(<nt def="NT-Char">Char</nt>* - 
(<nt def="NT-Char">Char</nt>* ']]&gt;' <nt def="NT-Char">Char</nt>*))
</rhs>
</prod>
<prod id="NT-CDEnd"><lhs>CDEnd</lhs>
<rhs>']]&gt;'</rhs>
</prod>
</scrap>

CDATAセクション内では，列<nt def="NT-CDEnd">CDEnd</nt>だけをマーク付けとして認識するので，不等号(小なり)及びアンパサンドは，そのリテラル形式で出現してよい。それらは，"<code>&amp;lt;</code>"及び"<code>&amp;amp;</code>"を使用して別扱いする必要はない。CDATAセクションは，入れ子にはできない。
</termdef>
</p>

<p>"<code>&lt;greeting&gt;</code>"及び"<code>&lt;/greeting&gt;</code>"を，<termref def="dt-markup">マーク付け</termref>ではなく，<termref def="dt-chardata">文字データ</termref>として認識するCDATAセクションの例を，次に示す。
<eg>&lt;![CDATA[&lt;greeting&gt;Hello, world!&lt;/greeting&gt;]]&gt;</eg>
</p>
</div2>
 
<div2 id="sec-prolog-dtd">
<head>書き及び文書型宣言</head>
 
<p><termdef id="dt-xmldecl" term="XML Declaration">XML文書は，使用するXMLの版を指定する<term>XML宣言</term>で始めてもよく，又そうするのが望ましい。
</termdef>
</p>
<p>この仕様書のこの版に適合することを示すためには，版番号 "<code>1.0</code>" を使用しなければならない。ある文書が，この仕様書のこの版に適合しないとき，値"<code>1.0</code>"を使用するのは，エラーとする。この仕様書の今後の版に"<code>1.0</code>"以外の値を付与することが，XML作業グループの意図だが，XMLの将来の版を作成することの確約を示すわけではなく，作成したとしても，番号付けについて，特定の方法を使用することの確約を示すわけでもない。将来の版の可能性を除外しないので，必要な場合，自動的な版の認識を可能とする手段として，この構成子を提供する。プロセサは，サポートしていない版でラベル付けした文書を受け取ったとき，エラーを通知してもよい。
</p>
<p>XML文書内のマーク付けの機能は，記憶構造及び論理構造を記述すること，並びに属性及び属性値の対を論理構造に関連づけることにある。XMLは，論理構造についての制約条件を定義するため，及びあらかじめ定義された記憶単位を使用できるための機構として，<termref def="dt-doctype">文書型宣言</termref>を提供する。<!-- old
The function of the markup in an XML document is to describe its
storage and logical structures, and associate attribute-value pairs with the
logical structure.
XML provides a
mechanism, the <termref def="dt-doctype">document type declaration</termref>, 
to
define constraints on that logical structure and to support the use of
predefined storage units. --><termdef id="dt-valid" term="Validity">XML文書が<term>妥当</term>とは，文書型宣言をもち，その文書型宣言に示す制約条件を満たすこととする。
</termdef></p>
<p>文書型宣言は，文書の最初の<termref def="dt-element">要素</termref>の前に現れなければならない。
<scrap lang="ebnf" id="xmldoc">
<head>書き</head>
<prodgroup pcw2="6" pcw4="17.5" pcw5="9">
<prod id="NT-prolog"><lhs>prolog</lhs>
<rhs><nt def="NT-XMLDecl">XMLDecl</nt>? 
<nt def="NT-Misc">Misc</nt>* 
(<nt def="NT-doctypedecl">doctypedecl</nt> 
<nt def="NT-Misc">Misc</nt>*)?</rhs></prod>
<prod id="NT-XMLDecl"><lhs>XMLDecl</lhs>
<rhs>'&lt;?xml' 
<nt def="NT-VersionInfo">VersionInfo</nt> 
<nt def="NT-EncodingDecl">EncodingDecl</nt>? 
<nt def="NT-SDDecl">SDDecl</nt>? 
<nt def="NT-S">S</nt>? 
'?&gt;'</rhs>
</prod>
<prod id="NT-VersionInfo"><lhs>VersionInfo</lhs>
<rhs><nt def="NT-S">S</nt> 'version' <nt def="NT-Eq">Eq</nt> 
('"<nt def="NT-VersionNum">VersionNum</nt>"' 
| "'<nt def="NT-VersionNum">VersionNum</nt>'")</rhs>
</prod>
<prod id="NT-Eq"><lhs>Eq</lhs>
<rhs><nt def="NT-S">S</nt>? '=' <nt def="NT-S">S</nt>?</rhs></prod>
<prod id="NT-VersionNum">
<lhs>VersionNum</lhs>
<rhs>([a-zA-Z0-9_.:] | '-')+</rhs>
</prod>
<prod id="NT-Misc"><lhs>Misc</lhs>
<rhs><nt def="NT-Comment">Comment</nt> | <nt def="NT-PI">PI</nt> | 
<nt def="NT-S">S</nt></rhs></prod>
</prodgroup>
</scrap></p>

<p>
例えば，次に示す完全なXML文書は，<termref def="dt-wellformed">整形式</termref>であるが<termref def="dt-valid">妥当</termref>ではない。
<greeting>Hello, world!</greeting>
]]></eg>
次の文書も同様とする。
<eg><![CDATA[<greeting>Hello, world!</greeting>
]]></eg>
</p>
<p><termdef id="dt-doctype" term="Document Type Declaration">
XMLの<term>文書型宣言</term>は，ある文書クラスのための文法を提供する<termref def="dt-markupdecl">マーク付け宣言</termref>を含むか，又は参照する。この文法を，文書型定義又は<term>DTD</term>という。文書型宣言は，マーク付け宣言を含んだ外部サブセット(特別な種類の<termref def="dt-extent">外部実体</termref>)を参照でき，又は内部サブセットに直接マーク付け宣言を含むこともできる。さらに，その両方も可能とする。ある文書のDTDは，両方のサブセットをまとめたものとして構成する。</termdef>
</p>
<p><termdef id="dt-markupdecl" term="markup declaration">
<term>マーク付け宣言</term>は，<termref def="dt-eldecl">要素型宣言</termref>， <termref def="dt-attdecl">属性リスト宣言</termref>，<termref def="dt-entdecl">実体宣言</termref>又は<termref def="dt-notdecl">記法宣言</termref>とする。</termdef>次に示す整形式制約及び妥当性制約に規定するが，これらの宣言は，<termref def="dt-PE">パラメタ実体</termref>内に全体又は一部が含まれてもよい。詳しい規定は，<titleref xml-link="simple" href="sec-physical-struct">物理構造</titleref>に関する規定を参照のこと。</p>
<scrap lang="ebnf" id="dtd">
<head>文書型定義</head>
<prodgroup pcw2="6" pcw4="17.5" pcw5="9">
<prod id="NT-doctypedecl"><lhs>doctypedecl</lhs>
<rhs>'&lt;!DOCTYPE' <nt def="NT-S">S</nt> 
<nt def="NT-Name">Name</nt> (<nt def="NT-S">S</nt> 
<nt def="NT-ExternalID">ExternalID</nt>)? 
<nt def="NT-S">S</nt>? ('[' 
(<nt def="NT-markupdecl">markupdecl</nt> 
| <nt def="NT-PEReference">PEReference</nt> 
| <nt def="NT-S">S</nt>)*
']' 
<nt def="NT-S">S</nt>?)? '&gt;'</rhs>
<vc def="vc-roottype"/>
<!--<vc def="vc-nonnullDTD"/>-->
</prod>
<!--
<prod id='NT-markupdecls'><lhs>markupdecls</lhs>
<rhs>
(<nt def='NT-S'>S</nt>?
<nt def='NT-markupdecl'>markupdecl</nt>
<nt def='NT-S'>S</nt>?)*
</rhs></prod>
-->
<prod id="NT-markupdecl"><lhs>markupdecl</lhs>
<rhs><nt def="NT-elementdecl">elementdecl</nt> 
| <nt def="NT-AttlistDecl">AttlistDecl</nt> 
| <nt def="NT-EntityDecl">EntityDecl</nt> 
| <nt def="NT-NotationDecl">NotationDecl</nt> 
| <nt def="NT-PI">PI</nt> 
| <nt def="NT-Comment">Comment</nt>
<!--| <nt def='NT-InternalPERef'>InternalPERef</nt> --></rhs>
<vc def="vc-PEinMarkupDecl"/>
<wfc def="wfc-PEinInternalSubset"/>
</prod>
<!--
<prod id="NT-InternalPERef"><lhs>InternalPERef</lhs>
<rhs><nt def="NT-PEReference">PEReference</nt></rhs>
<wfc def="wfc-integraldec"/>
</prod>
-->
</prodgroup>
</scrap>
<vcnote id="vc-roottype">
<head>ルート要素型</head>
<p>
文書型宣言における<nt def="NT-Name">Name</nt>は，ルート要素の型とマッチしなければならない。
</p>
</vcnote>
<!--
<vcnote id="vc-nonnullDTD">
<head>Non-null DTD</head>
<p>
The internal and external subsets of the DTD must not both
be empty.
</p>
</vcnote>
-->
<vcnote id="vc-PEinMarkupDecl">
<head>宣言及びパラメタ実体が厳密に入れ子をなすこと</head>
<p>パラメタ実体<termref def="dt-repltext">の置換テキスト</termref>は，マーク付け宣言内において，厳密に入れ子になっていなければならない。つまり，マーク付け宣言(<nt def="NT-markupdecl">markupdecl</nt>)の最初又は最後の文字が，<termref def="dt-PERef">パラメタ実体参照</termref>の対象となる置換テキストに含まれれば，両方とも同じ置換テキストに含まれなければならない。</p>
</vcnote>
<wfcnote id="wfc-PEinInternalSubset">
<head>内部サブセット内のパラメタ実体</head>
<p>DTDの内部サブセットでは，<termref def="dt-PERef">パラメタ実体参照</termref>は，マーク付け宣言が出現可能な場所だけに出現できる。マーク付け宣言内には出現できない(この制約は，外部パラメタ実体又は外部サブセットでの参照には適用しない。)。
</p>
</wfcnote>
<p>
内部サブセットのときと同様に，外部サブセット及びDTDにおいて参照する任意の外部パラメタ実体は，非終端記号<nt def="NT-markupdecl">markupdecl</nt>によって許される型の，一連の完全なマーク付け宣言で構成されなければならない。マーク付け宣言の間には，空白又は<termref def="dt-PERef">パラメタ実体参照</termref>を置いてもよい。しかし，外部サブセット又は外部パラメタ実体の内容の一部は，<termref def="dt-cond-section">条件付きセクション</termref>を使用して無視してもよい。内部サブセットでは，これは許されない。
<!--In the external subset, however,  parameter-entity references can
be used to replace constructs prefixed by "<code>%</code>" in a production of
the grammar, and <termref def="dt-cond-section">conditional sections</termref>
may occur.
In the internal subset, by contrast, conditional sections may not
occur and the only parameter-entity references 
allowed are those which match the non-terminal 
<nt def="NT-InternalPERef">InternalPERef</nt>
within the rule for <nt def="NT-doctypedecl">markupdecl</nt>. 
-->
<scrap id="ext-Subset">
<head>外部サブセット</head>
<prodgroup pcw2="6" pcw4="17.5" pcw5="9">
<prod id="NT-extSubset"><lhs>extSubset</lhs>
<rhs>(
<nt def="NT-markupdecl">markupdecl</nt> 
| <nt def="NT-conditionalSect">conditionalSect</nt> 
| <nt def="NT-PEReference">PEReference</nt> 
| <nt def="NT-S">S</nt>
)*</rhs>
</prod>
</prodgroup>
</scrap></p>
<p>外部サブセット及び外部パラメタ実体は，その内では，パラメタ実体がマーク付け宣言の<emph>間</emph>だけでなく，マーク付け宣言の<emph>内</emph>でも認識される，という点でも内部サブセットとは異なる。
</p>
<p>文書型宣言付きのXML文書の例を，次に示す。
<!DOCTYPE greeting SYSTEM "hello.dtd">
<greeting>Hello, world!</greeting>
]]></eg>
<termref def="dt-sysid">システム識別子</termref> "<code>hello.dtd</code>"が，文書のDTDのURIとなる。</p>
<p>次の例のとおり，宣言を局所的に与えることもできる。
<!DOCTYPE greeting [
  <!ELEMENT greeting (#PCDATA)>
]>
<greeting>Hello, world!</greeting>
]]></eg>
外部サブセット及び内部サブセットの両方を使用するときは，内部サブセットが外部サブセットより先に出現したと見なす。<!--* 'is considered to'? boo. whazzat mean? -->これは，内部サブセットの実体及び属性リスト宣言が，外部サブセットの実体及び属性リスト宣言より優先するという効果をもたらす。
</p>
</div2>

<div2 id="sec-rmd">
<head>スタンドアロン文書宣言</head>
<p><termref def="dt-xml-proc">XMLプロセサ</termref>は，アプリケーションに文書の内容を渡すが，マーク付け宣言は，この内容に影響を与えることがある。属性のデフォルト値及び実体宣言をその例とする。XML宣言の一部分として出現できるスタンドアロン文書宣言は，文書が，そのマーク付け宣言の存在によって影響されないことを指し示す（普通，そのマーク付け宣言が存在しないために，これがいえる。）。
<scrap lang="ebnf" id="fulldtd">
<head>スタンドアロン文書宣言</head>
<prodgroup pcw2="4" pcw4="19.5" pcw5="9">
<prod id="NT-SDDecl"><lhs>SDDecl</lhs>
<rhs>
<nt def="NT-S">S</nt> 
'standalone' <nt def="NT-Eq">Eq</nt> "'" ('yes' | 'no') "'" 
</rhs>
<rhs>
| <nt def="NT-S">S</nt> 
'standalone' <nt def="NT-Eq">Eq</nt> '"' ('yes' | 'no') '"'
</rhs><vc def="vc-check-rmd"/></prod>
</prodgroup>
</scrap></p>
<p>スタンドアロン文書宣言においては, "<code>yes</code>"の値は，<termref def="dt-docent">文書実体</termref>の外部に（DTDの外部サブセット内に，又は内部サブセットから参照される外部パラメタ実体内に），XMLプロセサからアプリケーションへと渡される情報に影響するマーク付け宣言が存在しないことを意味する。"<code>no</code>"の値は，その外部マーク付け宣言が存在するか，又は存在する可能性があることを意味する。スタンドアロン文書宣言は，その<emph>宣言</emph>が文書外部に存在するかどうかを示すだけに注意すること。外部実体への参照が文書内に存在していても，その実体が内部的に宣言されているときは，文書のスタンドアロンの状態には影響を与えない。</p>

<p>外部にマーク付け宣言が存在しなければ，スタンドアロン文書宣言は意味をもたない。外部にマーク付け宣言が存在し，スタンドアロン文書宣言が存在しない場合は，<code>"no"</code> の値の設定を仮定する。</p>
<p>XML文書で <code>standalone="no"</code> が設定されているものは，あるアルゴリズムでスタンドアロン文書に変換でき，この文書は，ネットワーク配信アプリケーションにとって望ましいかもしれない。</p>
<vcnote id="vc-check-rmd">
<head>スタンドアロン文書宣言</head>
<p>スタンドアロン文書宣言は，何らかの外部マーク付け宣言が次のいずれかを宣言しているときは，値 "<code>no</code>" を取らなければならない。
<ulist>
<item><p>a) <termref def="dt-default">デフォルト</termref>値付きの属性であって，この属性が適用される要素が，属性値を指定せずに文書内に現れるもの。</p></item>
<item><p>b) <code>amp</code>,
<code>lt</code>,
<code>gt</code>,
<code>apos</code>,
<code>quot</code>以外の実体であって，その実体に対する<termref def="dt-entref">参照</termref>が文書内に出現するもの。</p>
</item>
<item><p>c) 値が<titleref href="AVNormalize">正規化</titleref>の対象となる属性であって，正規化の結果として変化する値が文書内で属性に指定されるもの。</p></item>
<item>
<p>d) <termref def="dt-elemcontent">要素内容</termref>をもつ要素型であって，空白がその要素型のいずれかのインスタンス内に直接現れるもの。
</p></item>
</ulist>
</p>
</vcnote>
<p>スタンドアロン文書宣言付きのXML宣言の例を，次に示す。
<eg>&lt;?xml version="1.0" standalone='yes'?&gt;</eg></p>
</div2>
<div2 id="sec-white-space">
<head>空白の取扱い</head>
<p>XML文書を編集するときは，マーク付けを目立たせ読みやすくするために，“空白”(スペース，タブ及び空白行。この仕様書では，非終端記号の<nt def="NT-S">S</nt>で表す)を使うと便利なことが多い。その空白は，配布する版の文書の一部として含めることを意図しないのを普通とする。しかし，“意味のある”空白であって，配布する版に残さなければならないものも多い。例えば，詩及びソースコードにおける空白がある。</p>
<p><termref def="dt-xml-proc">XMLプロセサ</termref>は，文書内のマーク付け以外のすべての文字を，そのまま変更せずにアプリケーションに渡さなければならない。<termref def="dt-validating">妥当性を検証するXMLプロセサ</termref>は，<termref def="dt-elemcontent">要素内容</termref>の中の空白を他の非マーク付け文字から区別し，アプリケーション側に要素内容の中の空白が重要でないということを伝えなければならない。</p>
<p>
"<code>xml:space</code>"という特別な<termref def="dt-attr">属性</termref>を文書に挿入することによって，空白を重要とする意図を示してもよい。この属性を適用する要素に現れる空白を，アプリケーションが重要なものとして扱うことを要求する，という意図を示す。</p>
<p>妥当な文書では，この属性を使用する場合は，他の属性と同じように<termref def="dt-attdecl">宣言</termref>しなければならない。宣言するときは，取り得る値を"<code>default</code>"及び "<code>preserve</code>"だけとする<termref def="dt-enumerated">列挙型</termref>でなければならない。
</p>
<p>値"<code>default</code>"は，アプリケーションのデフォルトの空白処理モードを，その要素に適用可能とすることを意味する。値"<code>preserve</code>"は，アプリケーションがすべての空白を保存することを意味する。この宣言の意図は，"<code>xml:space</code>" 属性の別の指定で上書きしない限り，要素の内容に現れるすべての要素に適用すると解釈する。</p>
<p>文書の<termref def="dt-root">ルート要素</termref>については，この属性の値を指定するか，又はこの属性のデフォルト値がある場合を除いては，アプリケーションによる空白の取扱いについて，いかなる意図も示さないと解釈する。</p>
<p>例を次に示す。
<eg><![CDATA[    <!ATTLIST poem   xml:space (default|preserve) 'preserve'>]]></eg>
</p>
</div2>
<div2 id="sec-line-ends">
<head>行末の取扱い</head>
<p>XMLの<termref def="dt-parsedent">構文解析対象実体</termref>は，通常コンピュータのファイル内に保存され，編集の便宜のために複数の行に分けることが多い。これらの行は，普通は，<code>CR</code> (#xD)コード及び <code>LF</code> (#xA)コードの何らかの組合せによって分けられる。</p>
<p><termref def="dt-app">アプリケーション</termref>の処理を簡単にするため，外部解析対象実体又は内部解析対象実体のリテラル実体値が，"<code>#xD#xA</code>" の２文字の連続とするリテラル又は<code>#xD</code>の単独のリテラルを含む場合に，<termref def="dt-xml-proc">XMLプロセサ</termref>は，アプリケーションに単一の文字<code>#xA</code>だけを渡さなければならない(この処理は，入力内に存在する改行コードを構文解析の前に正規化することによって，容易に実現できる。)。</p>
</div2>
<div2 id="sec-lang-tag">
<head>言語識別</head>
<p>文書処理においては，その文書の中身がどんな自然言語又は形式言語で書かれているか明示することが，役に立つことが多い。<!--ここで使用する“言語”という言葉の意味は，"Espa&#x00F1;ol" 及び"EBNF"の双方で例示される意味とする。--><!-- x00F1: spanish's small ntilde--></p>
<!--; この情報は（例をあげれば）文書の文字の表示，並びに情報抽出のための語幹・形態素解析及びテキストブロックの整形に影響を及ぼす可能性がある。-->
<p>XML文書内の要素のもつ内容又は属性値において使用する<!--自然又は形式-->言語を指定するために，"<code>xml:lang</code>" という名前の特別な<termref def="dt-attr">属性</termref>を，文書内に挿入してもよい。
<!--; この属性はXML規定の一部として，複数のXML&application;の相互運用性を高めるために定義する。-->
属性の値は，<bibref ref="RFC1766"/>“RFC1766：言語識別のためのタグ”によって規定される言語識別コードに従う。
<scrap lang="ebnf">
<head>言語識別</head>
<prod id="NT-LanguageID"><lhs>LanguageID</lhs>
<rhs><nt def="NT-Langcode">Langcode</nt> 
('-' <nt def="NT-Subcode">Subcode</nt>)*</rhs></prod>
<prod id="NT-Langcode"><lhs>Langcode</lhs>
<rhs><nt def="NT-ISO639Code">ISO639Code</nt> | 
<nt def="NT-IanaCode">IanaCode</nt> | 
<nt def="NT-UserCode">UserCode</nt></rhs>
</prod>
<prod id="NT-ISO639Code"><lhs>ISO639Code</lhs>
<rhs>([a-z] | [A-Z]) ([a-z] | [A-Z])</rhs></prod>
<prod id="NT-IanaCode"><lhs>IanaCode</lhs>
<rhs>('i' | 'I') '-' ([a-z] | [A-Z])+</rhs></prod>
<prod id="NT-UserCode"><lhs>UserCode</lhs>
<rhs>('x' | 'X') '-' ([a-z] | [A-Z])+</rhs></prod>
<prod id="NT-Subcode"><lhs>Subcode</lhs>
<rhs>([a-z] | [A-Z])+</rhs></prod>
</scrap>
<nt def="NT-Langcode">Langcode</nt>は，次のどれでもよい。
<ulist>
<item><p>a) <bibref ref="ISO639"/>“言語の名前表現のためのコード”で規定される2文字の言語コード</p></item>
<item><p>b) Internet Assigned Numbers Authority (IANA)で登録されている言語コード。これは，先頭が "<code>i-</code>" (又は"<code>I-</code>")で始まる。</p></item>
<item><p>c) ユーザによって定められた言語コード，又は私的な使用のために複数の団体間が取り決めたコード。これらは，今後IANAにおいて標準化又は登録されるコードとの競合を避けるために，先頭を"<code>x-</code>" 又は "<code>X-</code>" で始める。</p></item>
</ulist></p>
<p><nt def="NT-Subcode">Subcode</nt>は，複数回使ってもよい。最初のサブコードが存在し，その内容が二つの文字から成るときは，<bibref ref="ISO3166"/>ISO3166の“国名を表すコード(国コード)”でなければならない。最初のサブコードが3文字以上から成るときは，<nt def="NT-Langcode">Langcode</nt>の先頭が，"<code>x-</code>" 又は "<code>X-</code>"で始まらない限り，指定した言語に対するサブコードとし，IANAに登録されたものでなければならない。</p>
<p>言語コードは，小文字での表記を，国コードは，(存在するならば)大文字での表記を慣行とする。しかし，XML文書内における他の名前とは異なり，これらの値については，大文字及び小文字の区別をしないことに注意すること。</p>
<p>例を次に示す。
<eg><![CDATA[<p xml:lang="en">The quick brown fox jumps over the lazy dog.</p>
<p xml:lang="en-GB">What colour is it?</p>
<p xml:lang="en-US">What color is it?</p>
<sp who="Faust" desc='leise' xml:lang="de">
  <l>Habe nun, ach! Philosophie,</l>
  <l>Juristerei, und Medizin</l>
  <l>und leider auch Theologie</l>
  <l>]]><!-- x00DF german's es-zet; x00FC german's u-umlaut -->durchaus studiert mit hei&#223;em Bem&#252;h'n.<![CDATA[</l>
  </sp>]]></eg></p>
<!--<p>xml:lang の値は，要素の内容及び(属性の&default-value;で定めない限り)フリーテキスト(CDATA)の値をもつその要素へのすべての属性の値について，その両方に適用する。-->
<p><code>xml:lang</code>で宣言する意図は，<code>xml:lang</code>の別の指定で上書しない限り，指定した要素の内容に含むすべての要素に適用する。</p>
<!--ある要素における xml:lang 属性の値が定められておらず，DTDにおいてその&default-value;が定められていない場合，その要素のxml:lang 属性の値は，親要素での値が存在する場合は，それを引き継ぐ。 次の例における二つの<term>という名前の専門用語を表す要素は，xml:langの値に関しては，実際上，同じ値をもつ。

  <p xml:lang="en">Here the keywords are
  <term xml:lang="en">shift</term> and
  <term>reduce</term>. ...</p>

XML&processor;ではなく&application;が，この属性値の継承について責任をもつ。
-->
<p>
妥当な文書においては，この仕様書の他の場所で規定するとおり，この属性を必ず宣言しなければならない。通常，宣言は，次の形とする。
<eg>xml:lang  NMTOKEN  #IMPLIED</eg>
必要ならば，特定のデフォルト値を与えてもよい。英語を母語とする学生用のフランス語の詩集では，説明及び注を英語で記述すれば，xml:lang 属性を次のとおりに宣言することとなる。
<eg><![CDATA[    <!ATTLIST poem   xml:lang NMTOKEN 'fr'>
    <!ATTLIST gloss  xml:lang NMTOKEN 'en'>
    <!ATTLIST note   xml:lang NMTOKEN 'en'>]]></eg>
</p>
<!--
DTDの設計者は，スクリプトを言語(及びその派生体)に包摂して扱うのではなく，スクリプト及び言語を同次元で扱うのが適当な場合，言語属性と同様にスクリプト属性が存在すれば有用だと思うかもしれない。リンク要素において，参照された又はリンクされたリソースにおける(主要な)言語(場合によっては複数)を表す要素を定義するのも望ましい。しかし，これらの&application;は，この&TR-or-Rec;が規定する範囲外とする。-->
</div2>
</div1>
<!-- &Elements; -->

<div1 id="sec-logical-struct">
<head>論理構造</head>

<p><termdef id="dt-element" term="Element">いかなる<termref def="dt-xml-doc">XML文書</termref>も，一つ以上の<term>要素</term>を含む。要素の境界は, <termref def="dt-stag">開始タグ</termref>及び<termref def="dt-etag">終了タグ</termref>によって区切る。要素が<termref def="dt-empty">空</termref>要素のときは，<termref def="dt-eetag">空要素タグ</termref>で示す。各々の要素は，型をもつ。要素型は名前(共通識別子(generic identifier)又はGIと呼ぶことがある。)によって特定される。要素は，いくつかの属性をもつことができる。</termdef>属性は，<termref def="dt-attrname">名前</termref>及び<termref def="dt-attrval">値</termref>をもつ。</p>

<scrap lang="ebnf"><head>要素</head>
<prod id="NT-element"><lhs>element</lhs>
<rhs><nt def="NT-EmptyElemTag">EmptyElemTag</nt></rhs>
<rhs>| <nt def="NT-STag">STag</nt> <nt def="NT-content">content</nt> 
<nt def="NT-ETag">ETag</nt></rhs><wfc def="GIMatch"/></prod>
</scrap>
<p>この仕様書は，要素型及び属性の意味，使用方法，又は(構文に関することを除き)名前に制約を与えない。ただし，先頭が<code>(('X'|'x')('M'|'m')('L'|'l'))</code>にマッチする名前は，この版又は今後の版のこの仕様書での標準化のために予約する。</p>

<wfcnote id="GIMatch"><head>要素型のマッチ</head>
<p>要素の終了タグの<nt def="NT-Name">名前</nt>は，その要素の開始タグにおける型とマッチしなければならない。</p>
</wfcnote>

<div2 id="sec-starttags">
<head>開始タグ，終了タグ及び空要素タグ</head>
<p><termdef id="dt-stag" term="Start-Tag">空でない任意のXML要素の始まりは，<term>開始タグ</term>によってマーク付けする。
<scrap lang="ebnf"><head>開始タグ</head>
<prodgroup pcw2="6" pcw4="15" pcw5="11.5">
<prod id="NT-STag"><lhs>STag</lhs><rhs>'&lt;' <nt def="NT-Name">Name</nt> (<nt def="NT-S">S</nt> <nt def="NT-Attribute">Attribute</nt>)* <nt def="NT-S">S</nt>? '&gt;'</rhs><wfc def="uniqattspec"/></prod>
<prod id="NT-Attribute"><lhs>Attribute</lhs><rhs><nt def="NT-Name">Name</nt> <nt def="NT-Eq">Eq</nt> <nt def="NT-AttValue">AttValue</nt></rhs><vc def="ValueType"/><wfc def="NoExternalRefs"/><wfc def="CleanAttrVals"/></prod>
</prodgroup>
</scrap>
開始タグ及び終了タグ内の<nt def="NT-Name">Name</nt>は，要素の<term>型</term>を表わす。</termdef><termdef id="dt-attr" term="Attribute"><nt def="NT-Name">Name</nt>及び<nt def="NT-AttValue">AttValue</nt>の対を要素の<term>属性指定</term>といい</termdef>，<termdef id="dt-attrname" term="Attribute Name">個々の対における<nt def="NT-Name">Name</nt>は，<term>属性名</term></termdef>及び<termdef id="dt-attrval" term="Attribute Value"><nt def="NT-AttValue">AttValue</nt>の内容(区切り子<code>'</code>又は<code>"</code>の間の文字列)を<term>属性値</term>という。</termdef></p>

<wfcnote id="uniqattspec"><head>属性指定の一意性</head>
<p>開始タグ又は空要素タグでは，同一の属性名が２度以上出現してはならない。</p></wfcnote>
<vcnote id="ValueType"><head>属性値の型</head>
<p>属性は宣言されていなければならない。属性値の型は，その属性に対して宣言した型でなければならない(属性の型については，<titleref href="AttDecls">属性リスト宣言</titleref>についての規定を参照。)。</p></vcnote>
<wfcnote id="NoExternalRefs"><head>外部実体への参照がないこと</head>
<p>属性値には，外部実体への直接的又は間接的な参照を含むことはできない。</p></wfcnote>
<wfcnote id="CleanAttrVals"><head>属性値に<code>&lt;</code>を含まないこと</head>
<p>属性値内で直接的又は間接的に参照する実体(<code>&amp;lt;</code>を除く。)の<termref def="dt-repltext">置換テキスト</termref>には，<code>&lt;</code>を含んではならない。</p></wfcnote>

<p>開始タグの例を，次に示す。
<eg>&lt;termdef id="dt-dog" term="dog"&gt;</eg></p>
<p><termdef id="dt-etag" term="End Tag">開始タグで始まる要素の終わりは，<term>終了タグ</term>でマーク付けしなければならない。この終了タグは，対応する開始タグの要素型と同じ名前をもつ。
<scrap lang="ebnf"><head>終了タグ</head><prodgroup pcw2="6" pcw4="15" pcw5="11.5"><prod id="NT-ETag"><lhs>ETag</lhs><rhs>'&lt;/' <nt def="NT-Name">Name</nt> <nt def="NT-S">S</nt>? '&gt;'</rhs></prod></prodgroup></scrap></termdef></p>
<p>終了タグの例を，次に示す。
<eg>&lt;/termdef&gt;</eg></p>

<p><termdef id="dt-content" term="Content">要素の開始タグと終了タグとの間の<termref def="dt-text">テキスト</termref>を，その要素の<term>内容</term>という。
<scrap lang="ebnf"><head>要素の内容</head>
<prodgroup pcw2="6" pcw4="15" pcw5="11.5"><prod id="NT-content"><lhs>content</lhs><rhs>(<nt def="NT-element">element</nt> | <nt def="NT-CharData">CharData</nt> | <nt def="NT-Reference">Reference</nt> | <nt def="NT-CDSect">CDSect</nt> | <nt def="NT-PI">PI</nt> | <nt def="NT-Comment">Comment</nt>)*</rhs></prod></prodgroup></scrap></termdef></p>

<p><termdef id="dt-empty" term="Empty">要素が<term>空</term>のとき，その要素は，直後に終了タグをもつ開始タグ又は空要素タグで表現しなければならない。</termdef><termdef id="dt-eetag" term="empty-element tag"><term>空要素タグ</term>は，次の特別な形式をとる。
<scrap lang="ebnf"><head>空要素のためのタグ</head><prodgroup pcw2="6" pcw4="15" pcw5="11.5"><prod id="NT-EmptyElemTag"><lhs>EmptyElemTag</lhs><rhs>'&lt;' <nt def="NT-Name">Name</nt> (<nt def="NT-S">S</nt> <nt def="NT-Attribute">Attribute</nt>)* <nt def="NT-S">S</nt>? '/&gt;'</rhs><wfc def="uniqattspec"/></prod></prodgroup></scrap></termdef></p>

<!-- 門馬：上の“空要素のためのタグ(tags for empty elements)”は“空要素タグ(empty-element tag)”とすべきだと思いますが，いかがでしょうか -->

<p>空要素タグは，内容をもたない任意の要素の表現に利用できる。空要素タグで表現する要素を，キーワード<kw>EMPTY</kw>を用いて宣言しなくともよい。</p>
<p>空要素の例を，次に示す。
<eg>&lt;IMG align="left" src="http://www.w3.org/Icons/WWW/w3c_home" /&gt;&lt;br&gt;&lt;/br&gt;&lt;br/&gt;</eg></p>
</div2>

<div2 id="elemdecls"><head>要素宣言</head>
<p><termref def="dt-valid">妥当性</termref>を保証するため，要素宣言及び属性リスト宣言を用いて<termref def="dt-xml-doc">XML文書</termref>の<termref def="dt-element">要素</termref>の構造に，制約を加えることができる。</p>
<p>要素宣言は，要素の<termref def="dt-content">内容</termref>についての制約とする。</p>
<p>要素宣言は，要素の<termref def="dt-parentchild">子</termref>として出現可能な要素型について，制約を加えることが多い。ユーザのオプション指定によっては，要素宣言をもたない要素型が他の要素宣言によって参照されれば，XMLプロセサは，警告を出してもよい。しかし，これはエラーとはしない。</p>

<p><termdef id="dt-eldecl" term="Element Type declaration"><term>要素型宣言</term>は，次の形式をとる。
<scrap lang="ebnf"><head>要素型宣言</head><prodgroup pcw2="5.5" pcw4="18" pcw5="9">
<prod id="NT-elementdecl"><lhs>elementdecl</lhs>
<rhs>'&lt;!ELEMENT' <nt def="NT-S">S</nt> 
<nt def="NT-Name">Name</nt> 
<nt def="NT-S">S</nt> 
<nt def="NT-contentspec">contentspec</nt>
<nt def="NT-S">S</nt>? '&gt;'</rhs>
<vc def="EDUnique"/></prod>
<prod id="NT-contentspec"><lhs>contentspec</lhs>
<rhs>'EMPTY' 
| 'ANY' 
| <nt def="NT-Mixed">Mixed</nt> 
| <nt def="NT-children">children</nt>
</rhs>
<vc def="elementvalid"/>
</prod>
</prodgroup>
</scrap>
ここで，<nt def="NT-Name">Name</nt>は，宣言されている要素の型とする。</termdef></p>

<vcnote id="EDUnique"><head>要素宣言の一意性</head>
<p>要素型を２度以上宣言できない。</p></vcnote>

<vcnote id="elementvalid"><head>要素の妥当性</head>
<p>要素が<!-- said to be -->妥当とは，<nt def="NT-elementdecl">elementdecl</nt>にマッチする宣言であって，その<nt def="NT-Name">Name</nt>がその要素型とマッチし，次のいずれかの条件を満たす場合とする。<ulist>
<item><p>a) 宣言が<kw>EMPTY</kw>にマッチし，要素が<termref def="dt-content">内容</termref>をもたない。</p></item>
<item><p>b) 宣言が<nt def="NT-children">children</nt>にマッチし，要素の<termref def="dt-parentchild">子要素</termref>の並びが，内容モデルの正規表現によって生成される言語に属する。</p></item>
<item><p>c) 宣言が<nt def="NT-Mixed">mixed</nt>にマッチし，要素の内容が<termref def="dt-chardata">文字データ</termref>及び<termref def="dt-parentchild">子要素</termref>からなる。子要素の要素型は，要素の内容モデルに出現する名前にマッチする。</p></item>
<item><p>d) 宣言が<kw>ANY</kw>にマッチし，どの<termref def="dt-parentchild">子要素</termref>の要素型も宣言されている。</p></item></ulist>

</p></vcnote>
<!-- with the new VC, I don't think the next few paras add anything -TWB
<p><termdef id="dt-model" term="content model">An element can declared using a <term>content model</term>, in which case its content can be categorized as <termref def="dt-elemcontent">element content</termref> or <termref def='dt-mixed'>mixed content</termref>, as explained below.</termdef></p>
<p>An element whose type declared using the keyword <kw>EMPTY</kw> must be <termref def="dt-empty">empty</termref> and may be tagged using an <termref def="dt-eetag">empty-element tag</termref> when it appears in the document.</p>
<p>If an element type is declared using the keyword <kw>ANY</kw>, then there are no validity constraints on its content:  it may contain <termref def='dt-parentchild'>child elements</termref> of any type and number, interspersed with character data.</p> -->

<p>要素宣言の例を，次に示す。
<eg>
&lt;!ELEMENT br EMPTY&gt;
&lt;!ELEMENT p (#PCDATA|emph)* &gt;
&lt;!ELEMENT %name.para; %content.para; &gt;
&lt;!ELEMENT container ANY&gt;
</eg></p>

<div3 id="sec-element-content"><head>要素内容</head>

<p><termdef id="dt-elemcontent" term="Element content">ある型の要素が<termref def="dt-parentchild">子</termref>要素だけを含む(文字データを含まない。)とき，その要素<termref def="dt-stag">型</termref>は，<term>要素内容</term>をもつ，という。</termdef>この場合，制約は，内容モデルを含む。内容モデルは，子要素の型及び子要素の出現順序を制御する簡単な文法とする。この文法は，内容素子(<nt def="NT-cp">cp</nt>s)からなる。内容素子は，名前，内容素子の選択リスト又は内容素子の列リストから構成される。
<scrap lang="ebnf"><head>要素内容モデル</head><prodgroup pcw2="5.5" pcw4="16" pcw5="11">
<prod id="NT-children"><lhs>children</lhs><rhs>(<nt def="NT-choice">choice</nt> | <nt def="NT-seq">seq</nt>) ('?' | '*' | '+')?</rhs></prod><prod id="NT-cp"><lhs>cp</lhs><rhs>(<nt def="NT-Name">Name</nt> | <nt def="NT-choice">choice</nt> | <nt def="NT-seq">seq</nt>) ('?' | '*' | '+')?</rhs></prod>
<prod id="NT-choice"><lhs>choice</lhs><rhs>'(' <nt def="NT-S">S</nt>? cp ( <nt def="NT-S">S</nt>? '|' <nt def="NT-S">S</nt>? <nt def="NT-cp">cp</nt> )*<nt def="NT-S">S</nt>? ')'</rhs><vc def="vc-PEinGroup"/></prod>
<prod id="NT-seq"><lhs>seq</lhs><rhs>'(' <nt def="NT-S">S</nt>? cp ( <nt def="NT-S">S</nt>? ',' <nt def="NT-S">S</nt>? <nt def="NT-cp">cp</nt> )*<nt def="NT-S">S</nt>? ')'</rhs><vc def="vc-PEinGroup"/></prod>
<!-- <prod id='NT-cps'><lhs>cps</lhs><rhs><nt def='NT-S'>S</nt>? <nt def='NT-cp'>cp</nt> <nt def='NT-S'>S</nt>?</rhs></prod>
<prod id='NT-choice'><lhs>choice</lhs><rhs>'(' <nt def='NT-S'>S</nt>? <nt def='NT-ctokplus'>ctokplus</nt> (<nt def='NT-S'>S</nt>? '|' <nt def='NT-S'>S</nt>? <nt def='NT-ctoks'>ctoks</nt>)* <nt def='NT-S'>S</nt>? ')'</rhs></prod>
<prod id="NT-ctokplus"><lhs>ctokplus</lhs><rhs><nt def="NT-cps">cps</nt>('|' <nt def="NT-cps">cps</nt>)+</rhs></prod>
<prod id="NT-ctoks"><lhs>ctoks</lhs><rhs><nt def="NT-cps">cps</nt>('|' <nt def="NT-cps">cps</nt>)*</rhs></prod>
<prod id='NT-seq'><lhs>seq</lhs><rhs>'(' <nt def='NT-S'>S</nt>?<nt def='NT-stoks'>stoks</nt> (<nt def='NT-S'>S</nt>? ',' <nt def='NT-S'>S</nt>? <nt def='NT-stoks'>stoks</nt>)*<nt def='NT-S'>S</nt>? ')'</rhs></prod>
<prod id="NT-stoks"><lhs>stoks</lhs><rhs><nt def="NT-cps">cps</nt>(',' <nt def="NT-cps">cps</nt>)*</rhs></prod>
-->
</prodgroup></scrap>
ここで，<nt def="NT-Name">Name</nt>は，<termref def="dt-parentchild">子</termref>として出現してよい要素の型を示す。この文法で選択リストが現れる位置では，選択リスト内のいずれの内容素子も<termref def="dt-elemcontent">要素内容</termref>の中に現れてよい。列リストに現れる内容素子は，リストで指定する順番のとおりに，<termref def="dt-elemcontent">要素内容</termref>に現れなければならない。名前又はリストの後に出現するオプションの文字<!-- 門馬：characterを文字と訳しました -->は，リスト内の要素又は内容素子が，1回以上任意の回数(<code>+</code>)，0回以上任意の回数(<code>*</code>)又は0回若しくは1回(<code>?</code>)出現可能なことを規定する。ここで示す構文及び意味は，この仕様書における生成規則で用いるものと同一とする。</p>

<!-- 門馬：上の文では，“name又はlistの後に続く文字”が“listの出現を規定する”とあって，nameの出現を規定するとは書いてありません。修正が必要と考えます。 -->

<p>要素の内容が内容モデルにマッチするのは，列，選択及び繰返し演算子にしたがって，内容の中の要素と内容モデル内の要素型とをマッチさせながら，内容モデル内の一つのパスをたどれるときに限る。<termref def="dt-compat">互換性のため</termref>，文書内の要素が，内容モデルにおける要素型の複数の出現位置とマッチすることは，エラーとする。詳細な規定については，附属書の<titleref xml-link="simple" href="determinism">決定的内容モデル</titleref>の項を参照。
<!-- appendix <specref ref="determinism"/>. -->
<!-- appendix on deterministic content models. -->
</p>

<vcnote id="vc-PEinGroup">
<head>グループ及びパラメタ実体が厳密な入れ子をなしていること</head>
<p>パラメタ実体の<termref def="dt-repltext">置換テキスト</termref>は，かっこで囲まれたグループによって，厳密な入れ子を構成しなければならない。つまり，<nt def="NT-choice">選択</nt>，<nt def="NT-seq">列</nt>又は<nt def="NT-Mixed">混在</nt>部品に，開きかっこ又は閉じかっこのいずれか一方が<termref def="dt-PERef">パラメタ実体</termref>の置換テキストに含れれば，他方も同じ置換テキストに含まれなければならない。</p>
<p><termref def="dt-interop">相互運用性のため</termref>，パラメタ実体参照が<nt def="NT-choice">選択</nt>，<nt def="NT-seq">列</nt>又は<nt def="NT-Mixed">混在</nt>内容に含まれれば，その置換テキストは空でないことが望ましく，置換テキストの先頭及び末尾の空白でない文字は，コネクタ(<code>|</code>又は<code>,</code>)でない方がよい。
</p>
</vcnote>
<p>要素内容モデルのいくつかの例を，次に示す。
<eg>&lt;!ELEMENT spec (front, body, back?)&gt;
&lt;!ELEMENT div1 (head, (p | list | note)*, div2*)&gt;
&lt;!ELEMENT dictionary-body (%div.mix; | %dict.mix;)*&gt;</eg></p>
</div3>

<div3 id="sec-mixed-content">
<head>混合内容</head>
 
<p><termdef id="dt-mixed" term="Mixed Content">ある要素型の要素内に，<termref def="dt-parentchild">子</termref>要素に混在して文字データが含まれる可能性があるとき，その要素<termref def="dt-stag">型</termref>は，<term>混合内容</term>をもつという。</termdef>この場合，子要素の型についての制約が存在してもよい<!-- 門馬：“may be constrained”を単に「制約される」と訳しました。 -->が，子要素の順序又は出現回数についての制約はないとする。
<scrap lang="ebnf">
<head>混合内容宣言</head>
<prodgroup pcw2="5.5" pcw4="16" pcw5="11">
<prod id="NT-Mixed"><lhs>Mixed</lhs>
<rhs>'(' <nt def="NT-S">S</nt>? 
'#PCDATA'
(<nt def="NT-S">S</nt>? 
'|' 
<nt def="NT-S">S</nt>? 
<nt def="NT-Name">Name</nt>)* 
<nt def="NT-S">S</nt>? 
')*' </rhs>
<rhs>| '(' <nt def="NT-S">S</nt>? '#PCDATA' <nt def="NT-S">S</nt>? ')'
</rhs><vc def="vc-PEinGroup"/>
<vc def="vc-MixedChildrenUnique"/>
</prod>
<!--
<prod id="NT-Mtoks"><lhs>Mtoks</lhs>
<rhs><nt def="NT-Name">Name</nt>
(<nt def='NT-S'>S</nt>? 
'|' 
<nt def='NT-S'>S</nt>? 
<nt def="NT-Name">Name</nt>)*
</rhs>
</prod>
-->
</prodgroup>
</scrap>
ここで，<nt def="NT-Name">Name</nt>は，子として出現してもよい要素の型を示す。
</p>

<vcnote id="vc-MixedChildrenUnique">
<head>要素型の重複の禁止</head>
<p>一つの混合内容宣言内に，同じ名前が複数回出現してはならない。
</p></vcnote>
<p>混合内容宣言の例を，次に示す。
<eg>&lt;!ELEMENT p (#PCDATA|a|ul|b|i|em)*&gt;
&lt;!ELEMENT p (#PCDATA | %font; | %phrase; | %special; | %form;)* &gt;
&lt;!ELEMENT b (#PCDATA)&gt;</eg></p>
</div3>
</div2>


<div2 id="attdecls">
<head>属性リスト宣言</head>
<p>
<termref def="dt-attr">属性</termref>は，名前及び値の対を<termref def="dt-element">要素</termref>に関連付けるために用いる。属性指定は，<termref def="dt-stag">開始タグ</termref>又は<termref def="dt-eetag">空要素</termref>タグ内でだけ可能とする。したがって，属性を認識するための生成規則は，<titleref href="sec-starttags">開始タグ</titleref>についての規定で示す。属性リスト宣言は，次の目的で用いる。
<ulist>
<item><p>a) ある要素型に適用する属性の集合を規定する。</p></item>
<item><p>b) 属性への型制約を設定する。</p></item>
<item><p>c) 属性の<termref def="dt-default">デフォルト値</termref>を規定する。</p></item>
</ulist>
</p>
<p>
<termdef id="dt-attdecl" term="Attribute-List Declaration">
<term>属性リスト宣言</term>は，ある要素型と関連付けられた各属性に対し，名前，データ型及び(存在すれば)デフォルト値を規定する。
<scrap lang="ebnf">
<head>属性リスト宣言</head>
<prod id="NT-AttlistDecl"><lhs>AttlistDecl</lhs>
<rhs>'&lt;!ATTLIST' <nt def="NT-S">S</nt> 
<nt def="NT-Name">Name</nt> 
<nt def="NT-AttDef">AttDef</nt>*
<nt def="NT-S">S</nt>? '&gt;'</rhs>
</prod>
<prod id="NT-AttDef"><lhs>AttDef</lhs>
<rhs><nt def="NT-S">S</nt> <nt def="NT-Name">Name</nt> 
<nt def="NT-S">S</nt> <nt def="NT-AttType">AttType</nt> 
<nt def="NT-S">S</nt> <nt def="NT-Default">Default</nt></rhs>
</prod>
</scrap>

<nt def="NT-AttlistDecl">AttlistDecl</nt>規則に存在する<nt def="NT-Name">Name</nt>は，要素型の名前とする。ユーザのオプション指定によっては，宣言していない要素型に対し属性を宣言したならば，XMLプロセサは，警告を出してもよい。しかし，これはエラーとはしない。
<nt def="NT-AttDef">AttDef</nt>規則における<nt def="NT-Name">Name</nt>は，属性の名前とする。
</termdef>
</p>
<p>
ある要素に対して，複数の<nt def="NT-AttlistDecl">AttlistDecl</nt>を与える場合，これらすべての内容はマージする。ある要素型の同じ属性に，複数の定義を与える場合には，最初の宣言を有効とし，他の宣言は無視する。<termref def="dt-interop">相互運用性のために</termref>，DTDの作成者は，ある要素型には高々一つの属性リスト宣言しか与えない，ある属性名には高々一つの属性定義しか与えない，及びすべての属性リスト宣言には少なくとも一つの属性定義を与える，という選択をしてもよい。相互運用性のために，XMLプロセサは，ユーザのオプション指定によっては，ある要素型に複数の属性リスト宣言を与えたり，ある属性に複数の属性定義を与えたりしたときに，警告を出してもよい。しかし，これは，エラーとはしない。
</p>

<div3 id="sec-attribute-types">
<head>属性の型</head>
<p>
XMLの属性の型は，３種類とする。これらは，文字列型，トークン化型及び列挙型とする。文字列型は，値として任意の文字列をとる。トークン化型は，次に示す字句及び意味に関する様々な制約をもつ。

<scrap lang="ebnf">
<head>Attribute Types</head>
<prodgroup pcw4="14" pcw5="11.5">
<prod id="NT-AttType"><lhs>AttType</lhs>
<rhs><nt def="NT-StringType">StringType</nt> 
| <nt def="NT-TokenizedType">TokenizedType</nt> 
| <nt def="NT-EnumeratedType">EnumeratedType</nt>
</rhs>
</prod>
<prod id="NT-StringType"><lhs>StringType</lhs>
<rhs>'CDATA'</rhs>
</prod>
<prod id="NT-TokenizedType"><lhs>TokenizedType</lhs>
<rhs>'ID'</rhs>
<vc def="id"/>
<vc def="one-id-per-el"/>
<vc def="id-default"/>
<rhs>| 'IDREF'</rhs>
<vc def="idref"/>
<rhs>| 'IDREFS'</rhs>
<vc def="idref"/>
<rhs>| 'ENTITY'</rhs>
<vc def="entname"/>
<rhs>| 'ENTITIES'</rhs>
<vc def="entname"/>
<rhs>| 'NMTOKEN'</rhs>
<vc def="nmtok"/>
<rhs>| 'NMTOKENS'</rhs>
<vc def="nmtok"/></prod>
</prodgroup>
</scrap>
</p>

<vcnote id="id">
<head>ID</head>
<p>
この型の値は，生成規則<code>Name</code>にマッチしなければならない。一つのXML文書内では，一つの名前が，この型の値として複数回現れてはならない。つまり，IDの値は，要素を一意に特定するしなければならない。
</p>
</vcnote>
<vcnote id="one-id-per-el">
<head>1要素ごとに1ID</head>
<p>
要素型は，複数のID属性値をもってはならない。
</p>
</vcnote>
<vcnote id="id-default">
<head>ID属性のデフォルト</head>
<p>
ID属性は，デフォルトとして，<code>#IMPLIED</code>又は<code>#REQUIRED</code>を宣言しなければならない。
</p>
</vcnote>
<vcnote id="idref">
<head>IDREF</head>
<p>
<kw>IDREF</kw>型の値は，生成規則<nt def="NT-Name">Name</nt>にマッチしなければならない。<kw>IDREFS</kw>型の値は，生成規則<nt def="NT-Names">Names</nt>にマッチしなければならない。各々の<nt def="NT-Name">Name</nt>は，XML文書内に存在する要素のID属性の値とマッチしなければならない。つまり，<kw>IDREF</kw>の値は，あるID属性の値とマッチしなければならない。
</p>
</vcnote>
<vcnote id="entname">
<head>実体名</head>
<p>
<kw>ENTITY</kw>型の値は，生成規則<nt def="NT-Name">Name</nt>にマッチしなければならない。<kw>ENTITIES</kw>型の値は，生成規則<nt def="NT-Names">Names</nt>にマッチしなければならない。各々の<nt def="NT-Name">Name</nt>は，<termref def="dt-doctype">DTD</termref>で宣言する<termref def="dt-unparsed">解析対象外実体</termref>とマッチしなければならない。
</p>
</vcnote>
<vcnote id="nmtok">
<head>名前トークン</head>
<p>
<kw>NMTOKEN</kw>型の値は，非終端記号<termref def="NT-Nmtoken">Nmtoken</termref>とマッチする文字列から構成されなければならない。<kw>NMTOKENS</kw>型の値は，非終端記号<termref def="NT-Nmtokens">Nmtokens</termref>とマッチする文字列から構成されなければならない。
</p>
</vcnote>
<p>
XMLプロセサは，アプリケーションに属性値を渡す前に，<titleref href="AVNormalize">属性値の正規化</titleref>で規定するとおりに，属性値を正規化しなければならない。
</p>
<p>
<termdef id="dt-enumerated" term="Enumerated Attribute Values"><term>列挙型の属性</term>は，宣言した値の一つを取ることができる。</termdef>列挙型には，2種類ある。

<scrap lang="ebnf">
<head>列挙属性の型</head>
<prod id="NT-EnumeratedType"><lhs>EnumeratedType</lhs> 
<rhs><nt def="NT-NotationType">NotationType</nt> 
| <nt def="NT-Enumeration">Enumeration</nt>
</rhs></prod>
<prod id="NT-NotationType"><lhs>NotationType</lhs> 
<rhs>'NOTATION' 
<nt def="NT-S">S</nt> 
'(' 
<nt def="NT-S">S</nt>?  
<nt def="NT-Name">Name</nt> 
(<nt def="NT-S">S</nt>? '|' <nt def="NT-Name">Name</nt>)*
<nt def="NT-S">S</nt>? ')'
</rhs>
<vc def="notatn"/></prod>
<prod id="NT-Enumeration"><lhs>Enumeration</lhs> 
<rhs>'(' <nt def="NT-S">S</nt>?
<nt def="NT-Nmtoken">Nmtoken</nt> 
(<nt def="NT-S">S</nt>? '|' 
<nt def="NT-S">S</nt>?  
<nt def="NT-Nmtoken">Nmtoken</nt>)* 
<nt def="NT-S">S</nt>? 
')'</rhs> 
<vc def="enum"/></prod>
</scrap>
</p>

<vcnote id="notatn">
<head>記法属性</head>
<p>この型の値は，宣言している<titleref href="Notations">記法</titleref>の名前の一つとマッチしなければならない。つまり，宣言に存在する記法名は，すべて宣言されていなければならない。
</p>
</vcnote>
<vcnote id="enum">
<head>列挙</head>
<p>
この型の値は，宣言に存在する<nt def="NT-Nmtoken">Nmtoken</nt>トークンの一つとマッチしなければならない。
</p>
</vcnote>
<p>
<termref def="dt-interop">相互運用性のため</termref>，同じ<nt def="NT-Nmtoken">Nmtoken</nt>は，単一要素型の列挙型の属性として，複数回現れない方がよい。
</p>
</div3>

<div3 id="sec-attr-defaults">
<head>属性のデフォルト</head>
 
<p>
<termref def="dt-attdecl">属性宣言</termref>は，属性の指定が必須かどうかについての情報を与える。必須でない場合には，文書内で属性を指定しないとき，XMLプロセサの処理方法の情報も与える。

<scrap lang="ebnf">
<head>属性のデフォルト</head>
<prodgroup pcw4="14" pcw5="11.5">
<prod id="NT-Default"><lhs>Default</lhs>
<rhs>'#REQUIRED' 
|&#160;'#IMPLIED' </rhs>
<rhs>| (('#FIXED' S)? <nt def="NT-AttValue">AttValue</nt>)</rhs>
<vc def="defattrvalid"/>
<wfc def="CleanAttrVals"/>
</prod>
</prodgroup>
</scrap>
<!-- improved by bosak
<scrap lang='ebnf'>
<head>Attribute Defaults</head>
<prod id='NT-Default'><lhs>Default</lhs>
<rhs>'#REQUIRED' 
|&nbsp;'#IMPLIED' </rhs>
<vc def='defattrvalid'/>
<wfc def="CleanAttrVals"/>
<rhs>| (('#FIXED' S)? <nt def='NT-AttValue'>AttValue</nt>)</rhs>
</prod>
</scrap>-->
</p>

<vcnote id="defattrvalid">
<head>属性デフォルトの正しさ</head>
<p>
宣言したデフォルト値は，宣言した属性型の字句制約を満たさなければならない。
</p>
</vcnote>
<p>
<kw>#REQUIRED</kw>を指定したとき，この要素型の<termref def="dt-stag">開始タグ</termref>であって，この属性に値を与えないものをXMLプロセサが見つけたならば，その文書は<termref def="dt-valid">妥当</termref>とはしない。<kw>#IMPLIED</kw>を指定したとき，この属性を省略したら，XMLプロセサは，属性値を指定しないことをアプリケーションに伝えなければならない。このとき，アプリケーションの振舞いについての制約はない。
</p>
<p>
<termdef id="dt-default" term="Attribute Default">
属性が<kw>#REQUIRED</kw>でも<kw>#IMPLIED</kw>でもないときには，<nt def="NT-AttValue">AttValue</nt>の値が，<term>デフォルト値</term>となる。<kw>#FIXED</kw>の場合，デフォルト値と異なる値が指定されれば，その文書は，<termref def="dt-valid">妥当</termref>としない。デフォルト値を宣言している場合，この属性の省略を見つけたら，宣言したデフォルト値を属性値に指定しているとして，XMLプロセサは振る舞うことが望ましい。
</termdef></p>

<p>属性リスト宣言の例を，次に示す。

<eg>&lt;!ATTLIST termdef
          id      ID      #REQUIRED
          name    CDATA   #IMPLIED&gt;
&lt;!ATTLIST list
          type    (bullets|ordered|glossary)  "ordered"&gt;
&lt;!ATTLIST form
          method  CDATA   #FIXED "POST"&gt;</eg></p>
</div3>

<div3 id="AVNormalize">
<head>属性値の正規化</head>
<p>
XMLプロセサは，属性値をアプリケーションに渡す前に，次のとおりに正規化しなければならない。

<ulist>
<item>
<p>a) まず，属性値及びその中の実体内で，行末又は行境界(又はシステムによってはレコード境界)として使われる文字列を，スペース文字(#x20)一つに置き換えなければならない(「<titleref xml-link="simple" href="sec-line-ends">行末の扱い</titleref>」も参照のこと。)。
</p></item>
<item>
<p>b) 次に，文字参照及び内部解析対象実体への参照は，展開しなければならない。外部実体への参照は，エラーとする。
</p></item>
<item>
<p>c) 最後に，属性の型が<kw>CDATA</kw>でなければ，空白文字列は，すべてスペース文字(#x20)一つに正規化し，残りの空白文字は，削除しなければならない。
</p></item>
</ulist>

妥当性を検証しないパーサは，宣言が見つからない属性は，すべて，<kw>CDATA</kw>を宣言しているとして扱うことが望ましい。</p>
</div3>
</div2>

<div2 id="sec-condition-sect">
<head>条件付きセクション</head>
<p>
<termdef id="dt-cond-section" term="conditional section">
<term>条件付きセクション</term>とは，<termref def="dt-doctype">文書型宣言の外部サブセット</termref>の一部とし，制御キーワードの指定によって，DTDの論理構造に含めたり，除いたりする部分とする。
</termdef>

<scrap lang="ebnf">
<head>条件付きセクション</head>
<prodgroup pcw2="9" pcw4="14.5">
<prod id="NT-conditionalSect"><lhs>conditionalSect</lhs>
<rhs><nt def="NT-includeSect">includeSect</nt>
| <nt def="NT-ignoreSect">ignoreSect</nt>
</rhs>
</prod>
<prod id="NT-includeSect"><lhs>includeSect</lhs>
<rhs>'&lt;![' S? 'INCLUDE' S? '[' 
<!-- (<nt def='NT-markupdecl'>markupdecl</nt> 
      | <nt def="NT-conditionalSect">conditionalSect</nt>  
      | <nt def="NT-S">S</nt>)*
-->
<nt def="NT-extSubset">extSubset</nt>
']]&gt;'
</rhs>
</prod>
<prod id="NT-ignoreSect"><lhs>ignoreSect</lhs>
<rhs>'&lt;![' S? 'IGNORE' S? '[' 
<nt def="NT-ignoreSectContents">ignoreSectContents</nt>*
']]&gt;'</rhs>
</prod>
<prod id="NT-ignoreSectContents"><lhs>ignoreSectContents</lhs>
<rhs><nt def="NT-Ignore">Ignore</nt>
('&lt;![' <nt def="NT-ignoreSectContents">ignoreSectContents</nt>
']]&gt;' 
<nt def="NT-Ignore">Ignore</nt>)*</rhs></prod>
<prod id="NT-Ignore"><lhs>Ignore</lhs>
<rhs><nt def="NT-Char">Char</nt>* - 
(<nt def="NT-Char">Char</nt>* ('&lt;![' | ']]&gt;') 
<nt def="NT-Char">Char</nt>*)
</rhs></prod>
<!--<rhs>
((<nt def='NT-SkipLit'>SkipLit</nt> 
| <nt def='NT-Comment'>Comment</nt>
| <nt def='NT-PI'>PI</nt>) - 
(<nt def='NT-Char'>Char</nt>* ']]&gt;' <nt def='NT-Char'>Char</nt>*))
| ('&lt;![' <nt def='NT-ignoreSectContents'>ignoreSectContents</nt>*
']]&gt;')
</rhs>
<rhs>
| (<nt def='NT-Char'>Char</nt> - (']' | [&lt;'"]))
</rhs>
<rhs>
| ('&lt;!' (<nt def='NT-Char'>Char</nt> - ('-' | '[')))
</rhs>-->
</prodgroup>
</scrap>
</p>

<p>条件付きセクションは，DTDの内部サブセット及び外部サブセットと同様に，完全な宣言，コメント又は入れ子になった条件付きセクションを，いくつか含んでよい。これらの間に，空白が現れてもよい。
</p>
<p>
条件付きセクションのキーワードが<code>INCLUDE</code>ならば，XMLプロセサは，この条件付きセクションの内容を，文書の一部として扱わなければならない。条件付きセクションのキーワードが<code>IGNORE</code>ならば，その条件付きセクションの内容は，文書の一部として扱わない。構文解析を正しく行うためには，無視する条件付きセクション(IGNORE)に関しても，内容を読まなければならないことに注意すること。これは，入れ子になった条件付きセクションを見つけ，(無視する)最も外側の条件付きセクションを正しく検出するためとする。キーワードを<code>INCLUDE</code>とする小さな条件付きセクションが，キーワードを<code>IGNORE</code>とするより大きな条件付きセクションに含まれるならば，外側及び内側の条件付きセクションの両方とも無視する。
</p>
<p>
条件付きセクションのキーワードがパラメタ実体参照ならば，XMLプロセサは条件付きセクションの扱いを判断する前に，このパラメタ実体を展開しなければならない。
</p>

<p>例を次に示す。

<eg>&lt;!ENTITY % draft 'INCLUDE' &gt;
&lt;!ENTITY % final 'IGNORE' &gt;
 
&lt;![%draft;[
&lt;!ELEMENT book (comments*, title, body, supplements?)&gt;
]]&gt;
&lt;![%final;[
&lt;!ELEMENT book (title, body, supplements?)&gt;
]]&gt;
</eg>
</p>
</div2>
<!-- 
<div2 id='sec-pass-to-app'>
<head>XML Processor Treatment of Logical Structure</head>
<p>When an XML processor encounters a start-tag, it must make
at least the following information available to the application:
<ulist>
<item>
<p>the element type's generic identifier</p>
</item>
<item>
<p>the names of attributes known to apply to this element type
(validating processors must make available names of all attributes
declared for the element type; non-validating processors must
make available at least the names of the attributes for which
values are specified.
</p>
</item>
</ulist>
</p>
</div2>
--> 

</div1>
<!-- &Entities; -->

<div1 id="sec-physical-struct">
<head>物理構造</head>
 
<p>
<termdef id="dt-entity" term="Entity">
XML文書は，一つ以上の記憶単位から構成する。この記憶単位を，<term>実体</term>という。実体は，<term>内容</term>をもち，文書実体(以降参照)及び<termref def="dt-doctype">外部DTDサブセット</termref>を除いて，<term>名前</term>で特定される。
</termdef>

<!-- Added for CFG -->
<!-- obscurity amputated by TWB -->
<!-- entire sentence amputated by CMSMcQ:  no one but NO ONE is
ready for entities declared as
<!ENTITY foo "http://www.foo.com/bar.xml#id">
and it's pointless to suggest that it's possible
under current circumstances. -->
<!-- An entity may be stored in, -->
<!--but need not be coterminous with, -->
<!-- but need not comprise the whole of,  -->
<!-- a single physical storage object such as a file or -->
<!-- database field. -->
<!-- End sentence added for CFG -->各XML文書は，<termref def="dt-docent">文書実体</termref>と呼ぶ実体を一つもつ。<termref def="dt-xml-proc">XMLプロセサ</termref>は，この文書実体から処理を開始する。文書実体が，文書のすべてを含んでもよい。</p>

<p>実体は，解析対象実体又は解析対象外実体とする。<termdef id="dt-parsedent" term="Text Entity"><term>解析対象実体</term>の内容は，解析対象実体の<termref def="dt-repltext">置換テキスト</termref>と呼ぶ。この<termref def="dt-text">テキスト</termref>は，文書の本体の一部として解釈する。
</termdef>
</p>

<p>
<termdef id="dt-unparsed" term="Unparsed Entity">
<term>解析対象外実体</term>は，内容が<termref def="dt-text">テキスト</termref>でもそうでなくともよいリソースとする。テキストの場合，XMLでなくともよい。各解析対象外実体には，<termref def="dt-notation">記法</termref>が関連付けられ，この記法は，名前で特定される。記法の名前及び関連付けられた識別子を，XMLプロセサがアプリケーションに渡すという要件以外は，XMLは，解析対象外実体の内容を制限しない。
</termdef> 
</p>

<p>解析対象実体は，実体参照によって名前で呼び出す。解析対象外実体は，<kw>ENTITY</kw>型又は<kw>ENTITIES</kw>型の属性の値として，名前で参照する。</p>

<p>
<termdef id="gen-entity" term="general entity"><term>一般実体</term>は，文書内容の中で使用する解析対象実体とする。あいまいにならない限り，この仕様書では，一般実体を単に<emph>実体</emph>と呼ぶ。</termdef><termdef id="dt-PE" term="Parameter entity">パラメタ実体は，DTD内で使用する解析対象実体とする。</termdef>これらの２種類の実体は，異なる書式で参照し，異なる文脈で認識する。</p>

<!--
<div2 id='sec-synchro'>
<head>Logical and Physical Structures</head>
<p>The logical and physical structures (elements and entities)
in an XML document must
be properly nested.
<termref def='dt-stag'>Tags</termref> and <termref def='dt-element'>elements</termref> must
each begin and end in the same <termref def='dt-entity'>entity</termref>,  but may
refer to other 
entities internally; <termref def='dt-comment'>comments</termref>, 
<termref def='dt-pi'>processing instructions</termref>, 
<termref def='dt-charref'>character
references</termref>, and 
<termref def='dt-entref'>entity references</termref> must each be contained entirely
within a single entity. Entities must each contain an integral number
of elements, comments, processing instructions, and references,
possibly together with character data not contained within any element
in the entity, or else they must contain non-textual data, which by
definition contains no elements.</p></div2>
-->

<div2 id="sec-references">
<head>文字参照及び実体参照</head>
<p>
<termdef id="dt-charref" term="Character Reference">
<term>文字参照</term>は，ISO/IEC 10646文字集合の特定の文字，例えば，入力機器から直接入力不可能な文字を参照する。

<scrap lang="ebnf">
<head>文字参照</head>
<prod id="NT-CharRef"><lhs>CharRef</lhs>
<rhs>'&amp;#' [0-9]+ ';' </rhs>
<rhs>| '&amp;#x' [0-9a-fA-F]+ ';'</rhs>
<wfc def="wf-Legalchar"/>
</prod>
</scrap>
<wfcnote id="wf-Legalchar">
<head>正当な文字</head>
<p>文字参照で参照する文字は，非終端記号<termref def="NT-Char">Char</termref>に従わなければならない。</p>
</wfcnote>
文字が "<code>&amp;#x</code>" で始まれば，終端の "<code>;</code>" までの数字及びアルファベットは，ISO/IEC 10646 の文字コードの16進数表現とする。
<!--日本語訳について: letterはアルファベットと訳した。 三好 -->
文字が "<code>&amp;#</code>" で始まれば，終端の "<code>;</code>" までの数字は，文字コードの10進数表現とする。
</termdef>
</p>

<p>
<termdef id="dt-entref" term="Entity Reference">
<term>実体参照</term>は，名前の付いた実体の内容を参照する。</termdef><termdef id="dt-GERef" term="General Entity Reference">一般実体への参照は，アンパサンド(<code>&amp;</code>)及びセミコロン(<code>;</code>)を区切り子として用いる。</termdef><termdef id="dt-PERef" term="Parameter-entity reference"><term>パラメタ実体</term>への参照は，パーセント記号(<code>%</code>)及びセミコロン(<code>;</code>)を区切り子として用いる。
</termdef>
</p>

<scrap lang="ebnf">
<head>実体参照</head>
<prod id="NT-Reference"><lhs>Reference</lhs>
<rhs><nt def="NT-EntityRef">EntityRef</nt> 
| <nt def="NT-CharRef">CharRef</nt></rhs></prod>
<prod id="NT-EntityRef"><lhs>EntityRef</lhs>
<rhs>'&amp;' <nt def="NT-Name">Name</nt> ';'</rhs>
<wfc def="wf-entdeclared"/>
<vc def="vc-entdeclared"/>
<wfc def="textent"/>
<wfc def="norecursion"/>
</prod>
<prod id="NT-PEReference"><lhs>PEReference</lhs>
<rhs>'%' <nt def="NT-Name">Name</nt> ';'</rhs>
<wfc def="wf-entdeclared"/>
<vc def="vc-entdeclared"/>
<wfc def="textent"/>
<wfc def="norecursion"/>
<wfc def="indtd"/>
</prod>
</scrap>

<wfcnote id="wf-entdeclared">
<head>実体が宣言されていること</head>
<p>DTDをもたない文書，パラメタ実体参照を含まない内部DTDサブセットだけをもつ文書，又は "<code>standalone='yes'</code>" をもつ文書において，実体参照で用いる <nt def="NT-Name">Name</nt> は，その実体の宣言で与える名前と，<termref def="dt-match">マッチ</termref>しなければならない。ただし，整形式の文書は，実体<code>amp</code>,
<code>lt</code>,
<code>gt</code>,
<code>apos</code>,
<code>quot</code> を宣言する必要はない。パラメタ実体の場合は，宣言は，参照に先行しなければならない。同様に，一般実体の場合は，属性リスト宣言のデフォルト値内での参照より先に，宣言が現れなければならない。</p>

<p>外部サブセット又は外部パラメタ実体で実体を宣言するとき，妥当性を検証しないプロセサが，宣言を読み，処理することを<titleref href="include-if-valid">義務づけない</titleref>。それらの文書では，実体は宣言されなければならないという規則は，整形式制約ではない。
</p>
</wfcnote>

<vcnote id="vc-entdeclared">
<head>実体が宣言されていること</head>
<p>
外部サブセット又は外部パラメタ実体をもっていて，"<code>standalone='no'</code>"をもつ文書において，実体参照で用いる <nt def="NT-Name">Name</nt> は，その実体の宣言で与える名前と<termref def="dt-match">マッチ</termref>しなければならない。相互運用性のため，妥当な文書は<titleref href="sec-escapes">あらかじめ定義した実体の規定</titleref>で指定した書式によって，実体 <code>amp</code>,
<code>lt</code>,
<code>gt</code>,
<code>apos</code>,
<code>quot</code>を宣言することが望ましい。パラメタ実体の場合は，宣言は，参照に先行しなければならない。同様に，一般実体の場合は，属性リスト宣言のデフォルト値内での参照よりも先に，宣言が現れなければならない。
</p>
</vcnote>

<!-- FINAL EDIT:  is this duplication too clumsy? -->

<wfcnote id="textent">
<head>解析対象実体</head>
<p>
実体参照は，<termref def="dt-unparsed">解析対象外実体</termref>の名前を含んでいてはならない。解析対象外実体は，<kw>ENTITY</kw>型又は<kw>ENTITIES</kw> 型として宣言した<termref def="dt-attrval">属性値</termref>としてだけ参照できる。
</p>
</wfcnote>

<wfcnote id="norecursion">
<head>再帰なし</head>
<p>解析対象実体は，それ自体への参照を，直接にも間接にも含んではならない。</p>
</wfcnote>

<wfcnote id="indtd">
<head>DTDの中</head>
<p>
パラメタ実体参照は，<termref def="dt-doctype">DTD</termref>内にだけ，出現してよい。
<!--
In the external DTD subset, a parameter-entity reference is 
recognized only at the locations where
the nonterminal <nt def="NT-PEReference">PEReference</nt> or the
special operator <code>%</code> appears in a production of the
grammar.  In the internal subset, parameter-entity references
are recognized only when they match 
the <nt def="NT-InternalPERef">InternalPERef</nt> non-terminal
in the production for <nt def="NT-markupdecl">markupdecl</nt>.
-->
</p>
</wfcnote>

<p>
文字参照及び実体参照の例を，次に示す。
<eg>Type &lt;key&gt;less-than&lt;/key&gt; (&amp;#x3C;) to save options.
This document was prepared on &amp;docdate; and
is classified &amp;security-level;.</eg>
</p>

<p>
パラメタ実体参照の例を，次に示す。
<eg>&lt;!ENTITY % ISOLat2
         SYSTEM "http://www.xml.com/iso/isolat2-xml.entities" &gt;
%ISOLat2;
</eg>
</p>
</div2>
 
<div2 id="sec-entity-decl">
<head>実体宣言</head>
 
<p>
<termdef id="dt-entdecl" term="entity declaration">
実体は，次のとおりに宣言する。
<scrap lang="ebnf">
<head>実体宣言</head>
<prodgroup pcw2="5" pcw4="18.5">
<prod id="NT-EntityDecl"><lhs>EntityDecl</lhs>
<rhs><nt def="NT-GEDecl">GEDecl</nt></rhs><com>一般実体</com>
<rhs>| <nt def="NT-PEDecl">PEDecl</nt></rhs><com>パラメタ実体</com>
</prod>
<prod id="NT-GEDecl"><lhs>GEDecl</lhs>
<rhs>'&lt;!ENTITY' <nt def="NT-S">S</nt> <nt def="NT-Name">Name</nt> 
<nt def="NT-S">S</nt> <nt def="NT-EntityDef">EntityDef</nt> 
<nt def="NT-S">S</nt>? '&gt;'</rhs>
</prod>
<prod id="NT-PEDecl"><lhs>PEDecl</lhs>
<rhs>| '&lt;!ENTITY' <nt def="NT-S">S</nt> '%' <nt def="NT-S">S</nt> 
<nt def="NT-Name">Name</nt> <nt def="NT-S">S</nt> 
<nt def="NT-PEDef">PEDef</nt> <nt def="NT-S">S</nt>? '&gt;'</rhs>
<com>パラメタ実体</com>
</prod>
<prod id="NT-EntityDef"><lhs>EntityDef</lhs>
<rhs><nt def="NT-EntityValue">EntityValue</nt>
</rhs>
<!--<wfc def="WF-EntityValue"/>-->
<rhs>| <nt def="NT-ExternalDef">ExternalDef</nt></rhs>
<!--<wfc def="WF-External"/>-->
</prod>
<!-- FINAL EDIT: what happened to WFs here? -->
<prod id="NT-PEDef"><lhs>PEDef</lhs>
<rhs><nt def="NT-EntityValue">EntityValue</nt> 
| <nt def="NT-ExternalID">ExternalID</nt></rhs></prod>
</prodgroup>
</scrap>

<nt def="NT-Name">Name</nt> は，<termref def="dt-entref">実体参照</termref>において実体を特定する。解析対象外実体ならば，<kw>ENTITY</kw> 型又は<kw>ENTITIES</kw>型の属性値内で，実体を特定する。同一の実体が一回以上宣言されれば，最初の宣言を用いる。ユーザのオプション指定によっては，複数回宣言される実体に関し，XMLプロセサは，警告を出してもよい。
</termdef>
</p>

<!--
<wfcnote id="WF-Entityvalue">
<head>Well-Formed Internal Entity</head>
<p>General entities defined by an <nt
def="NT-EntityValue">EntityValue</nt> must be well-formed, as defined
in section <specref ref="wf-entities"/>.
</p>
</wfcnote>
<wfcnote id="WF-External">
<head>Well-Formed External Entity</head>
<p>General text entities defined by an <nt
def="NT-ExternalDef">ExternalDef</nt>, must be well-formed, as defined
in the section on <titleref xml-link="simple"
href="wf-entities">well-formed entities.</titleref>.</p>
</wfcnote>
--> 

<div3 id="sec-internal-ent">
<head>内部実体</head>
<p>
<termdef id="dt-internent" term="Internal Entity Replacement Text">
実体の定義が <nt def="NT-EntityValue">EntityValue</nt>のとき，これを<term>内部実体</term>という。これは，別個の物理的記憶単位をもたず，実体の内容は，宣言内で与える。</termdef>正しく<termref def="dt-repltext">置換テキスト</termref>を生成するには，<termref def="dt-litentval">リテラル実体値</termref>内での実体参照及び文字参照の処理が，必要となるかもしれないことに注意する。詳細は，<titleref href="intern-replacement">内部実体の置換テキストの構築</titleref>を参照。

<!-- redundant -TWB
Within the <nt def="NT-EntityValue">EntityValue</nt>,
parameter-entity references and character references are recognized
and expanded immediately. 
General-entity references within the
replacement text are not recognized
at the time the entity declaration is parsed, though they may be
recognized when the entity itself is referred to.
-->

</p>

<p>
内部実体は，<termref def="dt-parsedent">解析対象実体</termref>とする。
</p>

<p>内部実体宣言の例を，次に示す。
<eg>&lt;!ENTITY Pub-Status "This is a pre-release of the specification."&gt;</eg></p>
</div3>
 
<div3 id="sec-external-ent">
<head>外部実体</head>
<p>
<termdef id="dt-extent" term="External Entity">
実体が内部実体でなければ，<term>外部実体</term>とし，次のとおりに宣言する。

<scrap lang="ebnf">
<head>外部実体宣言</head>
<prod id="NT-ExternalDef"><lhs>ExternalDef</lhs>
<rhs><nt def="NT-ExternalID">ExternalID</nt> 
<nt def="NT-NDataDecl">NDataDecl</nt>?</rhs></prod>
<prod id="NT-ExternalID"><lhs>ExternalID</lhs>
<rhs>'SYSTEM' <nt def="NT-S">S</nt> 
<nt def="NT-SystemLiteral">SystemLiteral</nt></rhs>
<rhs>| 'PUBLIC' <nt def="NT-S">S</nt> 
<nt def="NT-PubidLiteral">PubidLiteral</nt> 
<nt def="NT-S">S</nt> 
<nt def="NT-SystemLiteral">SystemLiteral</nt>
</rhs>
</prod>
<prod id="NT-NDataDecl"><lhs>NDataDecl</lhs>
<rhs><nt def="NT-S">S</nt> 'NDATA' <nt def="NT-S">S</nt> 
<nt def="NT-Name">Name</nt></rhs>
<vc def="not-declared"/></prod>
</scrap>

<nt def="NT-NDataDecl">NDataDecl</nt> が存在すれば，この実体は，<termref def="dt-unparsed">解析対象外実体</termref>とし，そうでなければ，解析対象実体とする。</termdef>
</p>

<vcnote id="not-declared">
<head>記法が宣言されていること</head>
<p>
<nt def="NT-Name">Name</nt> は，宣言した<termref def="dt-notation">記法</termref>の名前とマッチしなければならない。
</p>
</vcnote>

<p>
<termdef id="dt-sysid" term="System Identifier">
キーワード <kw>SYSTEM</kw> の後の <nt def="NT-SystemLiteral">SystemLiteral</nt> を，実体の<term>システム識別子</term>と呼ぶ。これはURIとし，その実体の内容を取り出すのに用いてもよい。</termdef>URIと共に使うことの多いハッシュ("<code>#</code>")及びフラグメント識別子は，正式には，URI自体の一部とはしない。フラグメント識別子が，システム識別子の部分として与えられている場合，XMLプロセサは，エラーを出してもよい。この仕様書の範囲外の情報(例えば，ある特定のDTDの特別なXML要素又は特定のアプリケーションの仕様によって定義された処理命令)によって上書きされない限り，相対的なURIは，その実体の位置，すなわち，その実体の宣言があるファイルに相対的とする。したがって，DTDの内部サブセットにある実体宣言での相対的なURIは，文書の位置について相対的とする。外部サブセットにある実体宣言での相対的なURIは，その外部サブセットを含むファイルの位置に相対的とする。
</p>

<p>
<termdef id="dt-pubid" term="Public identifier">
システム識別子以外に，外部実体は，<term>公開識別子</term>を含んでもよい。
</termdef>
実体の内容を取り出すXMLプロセサは，この公開識別子を用いて，代わりのURIの生成を試みてもよい。XMLプロセサがこれに失敗した場合は，システムリテラルとして指定したURIを用いなければならない。マッチする前に，公開識別子内にある空白文字からなる文字列は，すべて単一のスペース文字(#x20)に正規化しなければならず，前後の空白文字は削除しなければならない。
</p>

<p>外部実体宣言の例を，次に示す。
<eg>&lt;!ENTITY open-hatch
         SYSTEM "http://www.textuality.com/boilerplate/OpenHatch.xml"&gt;
&lt;!ENTITY open-hatch
         PUBLIC "-//Textuality//TEXT Standard open-hatch boilerplate//EN"
         "http://www.textuality.com/boilerplate/OpenHatch.xml"&gt;
&lt;!ENTITY hatch-pic
         SYSTEM "../grafix/OpenHatch.gif"
         NDATA gif &gt;</eg></p>
</div3>
 
</div2>

<div2 id="TextEntities">
<head>解析対象実体</head>
<div3 id="sec-TextDecl">
<head>テキスト宣言</head>
<p>外部解析対象実体は，<term>テキスト宣言</term>で始まってもよい。
<scrap lang="ebnf">
<head>テキスト宣言</head>
<prodgroup pcw4="12.5" pcw5="13">
<prod id="NT-TextDecl"><lhs>TextDecl</lhs>
<rhs>'&lt;?xml' 
<nt def="NT-VersionInfo">VersionInfo</nt>?
<nt def="NT-EncodingDecl">EncodingDecl</nt>
<nt def="NT-S">S</nt>? '?&gt;'</rhs>
<!-- <wfc def='wfc-xmldecliteral'/> -->
<!-- <wfc def='wfc-no-nonleading-encdec'/> -->
</prod>
</prodgroup>
</scrap>
</p>
<p>テキスト宣言は，そのままの形で現れなければならず，解析対象実体への参照を経由してはならないことに注意する。</p>
<p>外部解析対象実体において，テキスト宣言は，先頭以外のいかなる位置にも出現しない。</p>
</div3>
<div3 id="wf-entities">
<head>整形式の解析対象実体</head>
<p>ラベル<nt def="NT-document">document</nt>をもつ生成規則にマッチすれば，文書実体は，整形式とする。ラベル<nt def="NT-ExtParsedEnt">ExtParsedEnt</nt>をもつ生成規則にマッチすれば，外部の一般解析対象実体は，整形式とする。ラベル<nt def="NT-ExtPE">ExtPE</nt>をもつ生成規則にマッチすれば，外部パラメタ実体は，整形式とする。

<scrap lang="ebnf">
<head>整形式の解析対象実体</head>
<prod id="NT-ExtParsedEnt"><lhs>ExtParsedEnt</lhs>
<rhs><nt def="NT-TextDecl">TextDecl</nt>? 
<nt def="NT-content">content</nt></rhs>
</prod>
<prod id="NT-ExtPE"><lhs>ExtPE</lhs>
<rhs><nt def="NT-TextDecl">TextDecl</nt>? 
<nt def="NT-extSubset">extSubset</nt></rhs>
</prod>
</scrap>
置換テキストが，ラベル<nt def="NT-content">content</nt>をもつ生成規則にマッチすれば，内部の一般解析対象実体は，整形式とする。DTDを最後まで読み込まないと，確実にこれを判定できないことに注意。すべての内部のパラメタ実体は，定義によって整形式とする。
</p>
<p>実体が整形式な結果として，XML文書の論理的及び物理的構造は，正しく入れ子となる。<termref def="dt-stag">開始タグ</termref>，<termref def="dt-etag">終了タグ</termref>，<termref def="dt-empty">空要素タグ</termref>，<termref def="dt-element">要素</termref>，<termref def="dt-comment">コメント</termref>，<termref def="dt-pi">処理命令</termref>，<termref def="dt-charref">文字参照</termref>及び<termref def="dt-entref">実体参照</termref>が，一つの実体で開始し，別の実体で終了することはない。</p>
</div3>
<div3 id="charencoding">
<head>実体における文字符号化</head>
 
<p>XML文書内の外部解析対象実体は，各々，別の文字符号化方式を用いてもよい。すべてのXMLプロセサは，UTF-8で符号化した実体，UTF-16で符号化した実体を処理できなければならない。
<!--
It is recognized that for some purposes, the use of additional
ISO/IEC 10646 planes other than the Basic Multilingual Plane
may be required.  
A facility for handling characters in these planes is therefore a
desirable characteristic in XML processors and applications.
-->
</p>
<p>UTF-16で符号化した実体は，ISO/IEC 10646の付録E及びUnicodeの付録Bで規定するバイト順マーク(ZERO WIDTH NO-BREAK SPACE文字，#xFEFF)で始まらなければならない。これは，符号化の標識であって，XML文書のマーク付けの一部でも，文字データの一部でもない。XMLプロセサは，UTF-8で符号化した文書とUTF-16で符号化した文書との区別を行うために，この文字を使用可能でなければならない。</p>
<p>XMLプロセサは，UTF-8及びUTF-16で符号化した実体だけを読むことを必須とするが，他の符号化を世界では用いており，それらの符号化を用いる実体をXMLプロセサが処理できることが望ましい。UTF-8又はUTF-16以外の符号化方式を用いて格納する解析対象実体は，符号化宣言を含む<titleref href="TextDecl">テキスト宣言</titleref>で始めなければならない。
<scrap lang="ebnf">
<head>符号化宣言</head>
<prod id="NT-EncodingDecl"><lhs>EncodingDecl</lhs>
<rhs><nt def="NT-S">S</nt>
'encoding' <nt def="NT-Eq">Eq</nt> 
'"' <nt def="NT-EncName">EncName</nt> '"' | "'" 
<nt def="NT-EncName">EncName</nt> "'"
</rhs>
</prod>
<prod id="NT-EncName"><lhs>EncName</lhs>
<rhs>[A-Za-z] ([A-Za-z0-9._] | '-')*</rhs>
<com>ラテン文字だけを含む符号化名</com>
</prod>
</scrap>
<termref def="dt-docent">文書実体</termref>では，符号化宣言は，<termref def="dt-xmldecl">XML宣言</termref>の一部とする。<nt def="NT-EncName">EncName</nt>は，使用する符号化方式の名前とする。
</p>
<!-- FINAL EDIT:  check name of IANA and charset names -->
<p>符号化宣言では，値<code>UTF-8</code>，<code>UTF-16</code>，<code>ISO-10646-UCS-2</code>及び<code>ISO-10646-UCS-4</code>は，Unicode及びISO/IEC 10646の各種符号化のために用いる。値<code>ISO-8859-1</code>から<code>ISO-8859-9</code>までは，ISO 8859の対応するパートのために用いる。値<code>ISO-2022-JP</code>，<code>Shift_JIS</code>及び<code>EUC-JP</code>は，JIS X-0208-1997の各種符号化のために用いる。XMLプロセサは，それ以外の符号化方式を認識してもよい。Internet Assigned Numbers Authority (IANA)に，(<emph>charset</emph>sとして)登録された文字符号化方式については，これら以外についても，登録された名前で参照することが望ましい。これらの登録された名前は，大文字・小文字の区別をせずに定義されているので，これらに対する比較を試みるプロセサは，大文字・小文字の区別をしない方法をとるのが望ましいことに注意する。</p>
<p>XML処理系に渡された実体が，符号化宣言を含むにもかかわらず，宣言で示したもの以外の方式で符号化されていたり，符号化宣言が，外部実体の最初以外の位置に出現すれば，<termref def="dt-error">エラー</termref>とする。
</p>
<p>バイト順マークでも符号化宣言でも始まらない実体は，UTF-8符号化でなければならない。</p>

<p><!-- XML processors should make an effort to use all available
information, internal and external, to aid in detecting an entity's correct
encoding.  Such information may include, but is not limited to:
<ulist><item><p>An HTTP header</p></item>
<item><p>A MIME header obtained other than through HTTP</p></item>
<item><p>Metadata provided by the native OS file system or by document
management software</p></item>
<item><p>The bit patterns at the front of an entity, which may
be analyzed to determine if
the application of any known encoding yields a valid encoding
declaration.  See <titleref href='sec-guessing'>the appendix on
autodetection of character sets</titleref> 
for a fuller description.</p></item></ulist> -->
処理できない符号化をもった実体をXMLプロセサが発見したときは，アプリケーションにその事実を通知し，<termref def="dt-fatal">致命的エラー</termref>として，処理を終了しなければならない。
<!--
inform the application of this fact and 
may 
allow the application to
request either that the entity should be treated as an <termref
def="dt-unparsed">unparsed entity</termref>, or that processing should
cease.-->
</p>
<p>符号化宣言の例を，次に示す。
<eg>&lt;?xml encoding='UTF-8'?&gt;
&lt;?xml encoding='EUC-JP'?&gt;</eg></p>
</div3>
</div2>
<div2 id="entproc">
<head>XMLプロセサによる実体及び参照の扱い</head>
<p>次の表は，文字参照，実体参照及び解析対象外実体の呼出しが現れる文脈及び各々の場合における<termref def="dt-xml-proc">XMLプロセサ</termref>に要求する振舞いを要約する。一番左の列のラベルは，認識の文脈を示す。
<glist>
<gitem><label>内容における参照</label>
<def><p>要素の<termref def="dt-stag">開始タグ</termref>及び<termref def="dt-etag">終了タグ</termref>の間の任意の場所での参照。非終端記号<nt def="NT-content">content</nt>に対応する。</p></def>
</gitem>
<gitem>
<label>属性値における参照</label>
<def><p><termref def="dt-stag">開始タグ</termref>の属性の値，又は<termref def="dt-attdecl">属性宣言</termref>におけるデフォルト値のいずれかでの参照。非終端記号<nt def="NT-AttValue">AttValue</nt>に対応する。</p></def></gitem>
<gitem>
<label>属性値として出現</label>
<def><p>参照ではなく，<nt def="NT-Name">Name</nt>として出現。<code>ENTITY</code>型として宣言した属性の値，又は<code>ENTITIES</code>型として宣言した属性の値におけるスペースで区切るトークンの一つとして出現する。</p>
</def></gitem>
<gitem><label>実体値における参照</label>
<def><p>実体の宣言における，パラメタ又は内部実体の<termref def="dt-litentval">リテラル実体値</termref>内の参照。非終端記号<nt def="NT-EntityValue">EntityValue</nt>に対応する。</p></def></gitem>
<gitem><label>DTDにおける参照</label>
<def><p><termref def="dt-doctype">DTD</termref>の内部サブセット又は外部サブセットでの参照。ただし，<nt def="NT-EntityValue">EntityValue</nt>又は<nt def="NT-AttValue">AttValue</nt>の外側とする。</p></def>
</gitem>
</glist></p>
<!-- border value changed by bosak -->
<htable border="1" cellpadding="7" align="center">
<!-- tbody wrapper added by bosak -->
<htbody>
<tr><td bgcolor="#c0d9c0" rowspan="2" colspan="1"/>
<td bgcolor="#c0d9c0" align="center" valign="bottom" colspan="4">実体の型</td>
<td bgcolor="#c0d9c0" rowspan="2" align="center">文字</td>
</tr>
<tr align="center" valign="bottom">
<td bgcolor="#c0d9c0">パラメタ</td>
<td bgcolor="#c0d9c0">内部 一般</td>
<td bgcolor="#c0d9c0">外部 解析対象実体 一般</td>
<td bgcolor="#c0d9c0">解析対象外実体</td>
</tr>
<tr align="center" valign="middle">
<!--<td bgcolor='&cellback;' rowspan='4'>Recognition
Context</td>-->
<td bgcolor="#c0d9c0" align="right">内容での 参照</td>
<td bgcolor="#c0d9c0"><titleref href="not-recognized">認識 しない</titleref></td>
<td bgcolor="#c0d9c0"><titleref href="included">取込み</titleref></td>
<td bgcolor="#c0d9c0"><titleref href="include-if-valid">検証のために取込み</titleref></td>
<td bgcolor="#c0d9c0"><titleref href="forbidden">禁止</titleref></td>
<td bgcolor="#c0d9c0"><titleref href="included">取込み</titleref></td>
</tr>
<tr align="center" valign="middle">
<td bgcolor="#c0d9c0" align="right">属性値での 参照</td>
<td bgcolor="#c0d9c0"><titleref href="not-recognized">認識 しない</titleref></td>
<td bgcolor="#c0d9c0"><titleref href="included">取込み</titleref></td>
<td bgcolor="#c0d9c0"><titleref href="forbidden">禁止</titleref></td>
<td bgcolor="#c0d9c0"><titleref href="forbidden">禁止</titleref></td>
<td bgcolor="#c0d9c0"><titleref href="included">取込み</titleref></td>
</tr>
<tr align="center" valign="middle">
<td bgcolor="#c0d9c0" align="right">属性値として 出現</td>
<td bgcolor="#c0d9c0"><titleref href="not-recognized">認識 しない</titleref></td>
<td bgcolor="#c0d9c0"><titleref href="not-recognized">禁止</titleref></td>
<td bgcolor="#c0d9c0"><titleref href="not-recognized">禁止</titleref></td>
<td bgcolor="#c0d9c0"><titleref href="notify">通知</titleref></td>
<td bgcolor="#c0d9c0"><titleref href="not recognized">認識 しない</titleref></td>
</tr>
<tr align="center" valign="middle">
<td bgcolor="#c0d9c0" align="right">実体値での 参照</td>
<td bgcolor="#c0d9c0"><titleref href="included">取込み</titleref></td>
<td bgcolor="#c0d9c0"><titleref href="bypass">処理しない</titleref></td>
<td bgcolor="#c0d9c0"><titleref href="bypass">処理しない</titleref></td>
<td bgcolor="#c0d9c0"><titleref href="forbidden">禁止</titleref></td>
<td bgcolor="#c0d9c0"><titleref href="included">取込み</titleref></td>
</tr>
<tr align="center" valign="middle">
<td bgcolor="#c0d9c0" align="right">DTDでの 参照</td>
<td bgcolor="#c0d9c0"><titleref href="as-PE">PEとして 取込み</titleref></td>
<td bgcolor="#c0d9c0"><titleref href="forbidden">禁止</titleref></td>
<td bgcolor="#c0d9c0"><titleref href="forbidden">禁止</titleref></td>
<td bgcolor="#c0d9c0"><titleref href="forbidden">禁止</titleref></td>
<td bgcolor="#c0d9c0"><titleref href="forbidden">禁止</titleref></td>
</tr>
</htbody>
</htable>
<div3 id="not-recognized">
<head>“認識しない”</head>
<p>DTDの外では，<code>%</code>文字は，いかなる特定の意味も，もたない。したがって，DTDではパラメタ実体参照として認識するものであっても，<nt def="NT-content">content</nt>内ではマーク付けとしては認識しない。同様に，適切に宣言した属性の値の中に現れる場合を除き，解析対象外実体の名前は，認識しない。
</p>
</div3>
<div3 id="included">
<head>“取込み”</head>
<p><termdef id="dt-include" term="Include">実体は，その<termref def="dt-repltext">置換テキスト</termref>を取り出し，処理すると，参照自体の代わりに，参照があった位置で，文書の一部として含まれるかのように<term>取り込まれる</term>。置換テキストは，<termref def="dt-chardata">文字データ</termref>及び(パラメタ実体を除く。)<termref def="dt-markup">マーク付け</termref>のいずれを含んでもよく，これらは，通常の方法で認識されなければならない。ただし，マーク付けの区切り子を別扱いするために用いる実体(<code>amp</code>,
<code>lt</code>,
<code>gt</code>,
<code>apos</code>,
<code>quot</code>)の置換テキストは，常にデータとして扱う(文字列"<code>AT&amp;amp;T;</code>"は，"<code>AT&amp;T;</code>"に展開され，残されたアンパサンドは，実体参照の区切り子としては認識しない。)。文字参照は，示した文字を参照自体の代わりに処理するとき，<term>取り込まれる</term>。
</termdef></p>
</div3>
<div3 id="include-if-valid">
<head>“検証のために取込み”</head>
<p>文書の妥当性を<termref def="dt-valid">検証</termref>するには，XMLプロセサが解析対象実体への参照を認識したとき，その置換テキストを<termref def="dt-include">取り込ま</termref>なければならない。実体が外部実体であって，XML文書の妥当性を検証しなければ，実体の置換テキストを取り込んでも<termref def="dt-may">よい</termref>が，そうしなくともよい。</p>
<p>この取決めは，SGML及びXMLの実体の機構が提供する自動取込み機能が，文書作成時のモジュール化を主な目的として設計されており，その他のアプリケーション(特に，文書のブラウズ)には，必ずしも適切ではない，という認識による。例えば，ブラウザは外部解析対象実体への参照を見つけると，その実体が存在するという表示だけを行い，表示を要求されたときにだけ，内容を取り出すかもしれない。
</p>
</div3>
<div3 id="forbidden">
<head>“禁止”</head>
<p>次は禁止されており，<termref def="dt-fatal">致命的エラー</termref>とする。
<ulist>
<item><p>a) <termref def="dt-unparsed">解析対象外実体</termref>への参照の出現。
</p></item>
<item><p>b) DTDの<nt def="NT-EntityValue">EntityValue</nt>又は<nt def="NT-AttValue">AttValue</nt>以外の部分における，文字参照又は一般実体への参照の出現。</p></item>
<item><p>c) 属性値内の外部実体への参照。</p>
</item>
</ulist>
</p>
</div3>
<div3 id="notify">
<head>“通知”</head>
<p><termref def="dt-unparsed">解析対象外実体</termref>の名前が，<kw>ENTITY</kw>又は<kw>ENTITIES</kw>の属性の値においてトークンとして現れたとき，プロセサは，アプリケーションに対して，関連付けられた<termref def="dt-notation">記法</termref>名，記法に対する<termref def="dt-sysid">システム</termref>識別子及び(存在すれば)<termref def="dt-pubid">公開</termref>識別子を通知しなければならない。</p>
</div3>
<div3 id="bypass">
<head>“処理しない”</head>
<p>一般実体参照が，実体宣言における<nt def="NT-EntityValue">EntityValue</nt>内に現れるとき，それは無視され，そのまま残る。</p>
</div3>
<div3 id="as-PE">
<head>“PEとして取込み”</head>
<p>外部解析対象実体の場合と同様に，パラメタ実体は，妥当性を<titleref href="include-if-valid">検証するときだけ取り込まれる</titleref>必要がある。パラメタ実体参照をDTD内に認識して取り込むとき，その<termref def="dt-repltext">置換テキスト</termref>は，その前後に一つのスペース文字(#x20)の付加によって引き伸ばされる。この意図は，パラメタ実体の置換テキストが，DTD内のいくつかの文法的トークンを完全に含むと，制約することにある。
</p>
</div3>
<!--
<div3 id='gen-char-entproc'>
<head>General and Character Entity Processing</head> 
<p>General-entity and character references are recognized in three
contexts: wherever the nonterminal <nt def='NT-content'>content</nt> may
appear, at any point within the nonterminal 
<nt def='NT-AttValue'>AttValue</nt>,
and within the 
<termref def='dt-litentval'>literal entity value</termref> 
(<nt def='NT-EntityValue'>EntityValue</nt>)  
of an internal entity declaration.
This section discusses the first two cases; the third
is discussed <titleref href='intern-replacement'>below</titleref>.
When an <termref def="dt-xml-proc">XML processor</termref> encounters
such a reference, or the name of an unparsed entity as the value
of an <kw>ENTITY</kw> or <kw>ENTITIES</kw> attribute, then:
<olist>

<item><p>In all cases, the XML processor may 
inform the application of the reference's occurrence and its identifier
(for an entity reference, the name; for a character
reference, 
the character number in decimal, hexadecimal, or binary form).</p></item>

<item><p>For both character and entity references, the processor must
remove the reference itself from the <termref def="dt-text">text</termref> data
before passing the data to the application.
</p></item>

<item><p>For character references, the processor must 
pass the character indicated
to the application in
place of the reference.
</p></item>

<item><p>For an external entity, the processor must inform the
application of the entity's <termref def="dt-sysid">system
identifier</termref>, and <termref def="dt-pubid">public identifier</termref> 
if any.
All strings
of white space in the public identifier must be normalized to single space characters (#x20),
and leading and trailing white space must be removed.</p></item>

<item><p>If the external entity is binary, the processor must inform the
application of the associated <termref def="dt-notation">notation</termref> 
name, and the notation's associated <termref def='dt-sysid'>system</termref> 
and <termref def='dt-pubid'>public</termref> (if any)
identifiers.</p></item>

<item><p><termdef id="dt-include" term="Include">For an internal
(parsed) entity, the processor must <term>include</term> the 
entity; that is, retrieve its replacement text 
and process it as a part of the document 
(i.e. as <nt def="NT-content">content</nt> or <nt
def="NT-AttValue">AttValue</nt>, whichever was being processed when
the reference was recognized), passing the result to the application
in place of the reference.  The replacement text may contain both 
<termref def='dt-chardata'>character data</termref>
and <termref def="dt-markup">markup</termref>, which must be recognized in
the usual way, except that the replacement text of entities used to escape
markup delimiters (the entities &magicents;) is always treated as
data.  (The string "<code>AT&amp;amp;T;</code>" expands to
"<code>AT&amp;T;</code>" since the ampersand replacing "<code>&amp;amp;</code>"
is not recognized
as an entity-reference delimiter.) </termdef></p>
<p>Since the entity  may contain other entity references,
an XML processor may have to repeat the inclusion process recursively.</p>
</item>
<item><p>If the entity is an external parsed entity, then in order to
<termref def="dt-valid">validate</termref> the XML document, the processor must
<termref def="dt-include">include</termref> the content of the
entity.</p></item>

<item><p>If the entity is an external parsed entity, and the processor is not
attempting to <termref def="dt-valid">validate</termref> the XML document, the
processor <termref def="dt-may">may</termref>, but need not, <termref
def="dt-include">include</termref> the entity's content.</p>
<p>This rule is based on the recognition that the automatic inclusion
provided by the SGML and XML entity mechanism, primarily designed
to support modularity in authoring, is not necessarily 
appropriate for other applications, in particular document browsing.
Browsers, for example, when encountering an external parsed entity reference,
might choose to provide a visual indication of the entity's
presence and retrieve it for display only on demand.
</p></item>
</olist>
</p>
<p><termdef id="dt-escape" term="escape">Entity and character
references can both be used to <term>escape</term> the left angle bracket,
ampersand, and other delimiters.   A set of general entities
(&magicents;) is specified for this purpose.
Numeric character references may also be used; they are
expanded immediately when recognized, and must be treated as
character data, so the numeric character references
"<code>&amp;#60;</code>" and "<code>&amp;#38;</code>" may be used to 
escape <code>&lt;</code> and <code>&amp;</code> when they occur
in character data.</termdef></p>
</div3>
<div3 id='PE-proc'>
<head>Parameter Entity Processing</head>
<p>Parameter-entity references are only recognized in the
<termref def='dt-doctype'>DTD</termref>.
Their processing, when they appear 
within the 
<termref def='dt-litentval'>literal entity value</termref> 
(<nt def='NT-EntityValue'>EntityValue</nt>) 
of an internal entity declaration,
is discussed <titleref href='intern-replacement'>below</titleref>.
They have these intended uses:
<olist>
<item><p>as a replacement for one or more complete markup declarations</p></item>
<item><p>as a replacement for one or more complete "groups" in 
element declarations</p></item>
<item><p>as a replacement for one or more complete "tokens" in
markup declarations</p></item>
</olist>
</p>
<p>The constraints requiring that PE replacement texts be properly nested
with <titleref href='vc-PEinMarkupDecl'>markup declarations</titleref>
and <titleref href='vc-PEinGroup'>content groups</titleref> 
govern the first two usages.</p>
<p>To support the third intended usage, 
when an XML processor encounters a parameter-entity reference
(outside of the 
<termref def='dt-litentval'>literal entity value</termref> in an entity
declaration), 
it must <termref def="dt-include">include</termref> 
the named entity, but first expand its 
<termref def='dt-repltext'>replacement text</termref> by attaching
space (#x20) characters to its beginning and the end, before
processing it.</p>
<p>The DTD text must match the relevant
rules of this specification's grammar after all parameter-entity 
references have been expanded.  
<!-In addition, parameter entities referred to in specific
contexts are required to satisfy certain constraints in their
replacement text; for example, a parameter entity referred to within
the internal DTD subset must match the rule for <nt
def="NT-markupdecl">markupdecl</nt>.  ->
</p>
</div3>
-->
</div2>
<div2 id="intern-replacement">
<head>内部実体置換テキストの構築</head>
<p>内部実体の取扱いの規定で，実体値を二つの形式に区別することは役に立つ。<termdef id="dt-litentval" term="Literal Entity Value"><term>リテラル実体値</term>は，実体宣言内に実際に存在する，引用符で囲む文字列とする。これは，非終端記号<nt def="NT-EntityValue">EntityValue</nt>にマッチする。</termdef><termdef id="dt-repltext" term="Replacement Text"><term>置換テキスト</term>は，文字参照及びパラメタ実体参照の置換え後における，実体の内容とする。</termdef></p>

<p>内部実体宣言内で与えるリテラル実体値<!-- replacement text -->(<nt def="NT-EntityValue">EntityValue</nt>)は，文字参照，パラメタ実体参照及び一般実体参照を含んでよい。これらの参照は，<!-- replacement text. -->リテラル実体値内に完全に含まれていなければならない。<termref def="dt-include">展開する</termref>実際の置換テキスト(先に示したもの)は，参照するパラメタ実体の<emph>置換テキスト</emph>を含まなければならず，リテラル実体値内での文字参照の代わりに参照した文字を含まなければならない。しかし，一般実体参照は，そのまま残し, 展開してはならない。
<!-- in the replacement text that is to be included. -->
例えば，次の宣言を与えたとする。

<eg><![CDATA[<!ENTITY % pub    "&#xc9;ditions Gallimard" >
<!ENTITY   rights "All rights reserved" >
<!ENTITY   book   "La Peste: Albert Camus, 
&#xA9; 1947 %pub;. &rights;" >]]></eg>
実体の置換テキスト"<code>book</code>"は，次のとおりとなる。
<eg>La Peste: Albert Camus, 
&#169; 1947 &#201;ditions Gallimard. &amp;rights;</eg>
参照"<code>&amp;book;</code>"が，文書の内容又は属性値内に出現していれば，一般実体参照"<code>&amp;rights;</code>"は，展開されている。</p>
<p>これらの単純な規則は，複合相互作用をもつ。
<!-- 日本語訳について： interaction = 相互作用（金本）-->
難しい例についての詳細は，<titleref href="sec-entexpand">実体参照の展開の付録</titleref>を参照のこと。
</p>
<!-- Replaced by the above -TB
<p>Implementors of XML processors need to know the rules for
expansion of references in more detail.  These rules only come into
play when the replacement text for an internal entity itself contains
other references.
<olist>
<item><p>In the replacement text of an internal entity, parameter-entity
references and character references in the replacement text 
are recognized and resolved 
when the entity declaration is parsed,
before the replacement text is stored in
the processor's symbol table.
General-entity references in the replacement text are not 
resolved when the entity declaration is parsed.</p></item>
<item><p>In the document, when a general-entity reference is
resolved, its replacement text is parsed.  Character references 
encountered in the replacement text are
resolved immediately; general-entity references encountered in the
replacement text may be resolved or left unresolved, as described 
<titleref href="entproc">above</titleref>.
Character and general-entity references must be
contained entirely within the entity's replacement text.  
</p></item>
</olist>
</p>

<p>Simple character references do not suffice to escape delimiters
within the replacement text of an internal entity:  they will be
expanded when the entity declaration is parsed, before the replacement
text is stored in the symbol table.  When the entity itself is
referred to, the replacement text will be parsed again, and the
delimiters (no longer character references) 
will be recognized as delimiters.  To escape the
characters &magicents; in an entity replacement text, use
a general-entity reference or a doubly-escaped character reference.
See <titleref href='sec-entexpand'>the appendix on expansion 
of entity references</titleref>
for detailed examples.</p>
-->


</div2>
<div2 id="sec-predefined-ent">
<head>定義済み実体</head>
<p><termdef id="dt-escape" term="escape">
実体参照及び文字参照のいずれも，不等号(小なり)，アンバサンド及び他の区切り子を<term>別扱い</term>するために使用できる。いくつかの一般実体（<code>amp</code>,
<code>lt</code>,
<code>gt</code>,
<code>apos</code>,
<code>quot</code>）を，この目的のために指定する。数値による文字参照も，同様の目的のために使用できる。文字参照は，認識されると直ちに展開され，文字データとして扱われるので，数値による文字参照"<code>&amp;#60;</code>"及び"<code>&amp;#38;</code>"は，文字データ内に出現する<code>&lt;</code>及び<code>&amp;</code>を別扱いするために使用できる。</termdef></p>
<p>すべてのXMLプロセサは，宣言されているかどうかに関係なく，これらの実体を認識しなくてはならない。<termref def="dt-interop">相互運用性のため</termref>，妥当なXML文書は，これらの実体を使用する前に，他の実体と同様に，宣言することが望ましい。実体を宣言する場合は，置換テキストを別扱いする一文字とする内部実体として，次のとおりに宣言しなければならない。
<eg><![CDATA[<!ENTITY lt     "&#38;#60;"> 
<!ENTITY gt     "&#62;"> 
<!ENTITY amp    "&#38;#38;"> 
<!ENTITY apos   "&#39;"> 
<!ENTITY quot   "&#34;"> 
]]></eg>
"<code>lt</code>"及び"<code>amp</code>"宣言内の"<code>&lt;</code>"及び"<code>&amp;</code>"文字は，実体の置換テキストが，整形式となるように二重に別扱いされることに注意。
</p>
</div2>


<div2 id="Notations">
<head>記法宣言</head>

 
<p>
<termdef id="dt-notation" term="Notation">
<term>記法</term>は，<termref def="dt-extent">解析対象外実体</termref>の形式を特定する名前か，又は<termref def="dt-pi">処理命令</termref>の対象とするアプリケーションを特定する名前とする。</termdef></p>
<p><termdef id="dt-notdecl" term="Notation Declaration">
<term>記法宣言</term>は，記法の名前及び外部識別子を提供する。この名前は，実体及び属性リスト宣言並びに属性指定に用いる。外部識別子は，与えられた記法のデータを処理できるヘルパアプリケーションを，XMLプロセサ又はクライアントアプリケーションが探すために，利用できる。
<scrap lang="ebnf">
<head>記法宣言</head>
<prod id="NT-NotationDecl"><lhs>NotationDecl</lhs>
<rhs>'&lt;!NOTATION' <nt def="NT-S">S</nt> <nt def="NT-Name">Name</nt> 
<nt def="NT-S">S</nt> 
(<nt def="NT-ExternalID">ExternalID</nt> | 
<nt def="NT-PublicID">PublicID</nt>)
<nt def="NT-S">S</nt>? '&gt;'</rhs></prod>
<prod id="NT-PublicID"><lhs>PublicID</lhs>
<rhs>'PUBLIC' <nt def="NT-S">S</nt> 
<nt def="NT-PubidLiteral">PubidLiteral</nt> 
</rhs></prod>
</scrap>
</termdef></p>
<p>宣言し，属性値，属性定義又は実体宣言で参照するすべての記法について，XMLプロセサは，記法の名前及び外部識別子をアプリケーションに提供しなければならない。さらに，外部識別子を，<termref def="dt-sysid">システム識別子</termref>，ファイル名又はその他の情報に展開してもよく，これらを用いて，アプリケーションは，その記法のデータを処理するプロセサを起動する。(しかし，XMLプロセサ又はアプリケーションが動作するシステムでは利用できない記法を，XML文書が宣言し参照しても，これは，エラーとはしない。）</p>
</div2>


<div2 id="sec-doc-entity">
<head>文書実体</head>

<p><termdef id="dt-docent" term="Document Entity"><term>文書実体</term>は，実体の形成する木構造のルートであって，<termref def="dt-xml-proc">XMLプロセサ</termref>が，処理を開始する地点とする。</termdef>この仕様書は，XMLプロセサが，文書実体の存在する場所をどのように見つけるかは，規定しない。他の実体と異なり，文書実体は名前をもたず，いかなる識別もなしにプロセサへの入力ストリームに出現してもよい。</p>
</div2>


</div1>
<!-- &Conformance; -->
<div1 id="sec-conformance">
<head>適合性</head>

<p>適合する<termref def="dt-xml-proc">XMLプロセサ</termref>は，妥当性を検証するもの及び妥当性を検証しないものの，二つに分類される。</p>
<p>妥当性を検証するシステム及び妥当性を検証しないシステムは，この仕様書が規定する整形式制約への違反を報告しなければならない。</p>
<p><termdef id="dt-validating" term="Validating Processor"><term>妥当性を検証するプロセサ</term>は，<termref def="dt-doctype">DTD</termref>内の宣言によって示された，制約への違反を報告しなければならない。さらに，この仕様書が規定する妥当性制約への違反を，すべて報告しなければならない。
</termdef>
</p>
</div1>

<div1 id="sec-notation">
<head>記法</head>

<p>XMLの形式的な文法は，簡単な拡張Backus-Naur Form(EBNF)記法によって与える。文法の各規則は，次の形式で，記号を一つ定義する。
<eg>symbol ::= expression</eg></p>
<p>記号は，正規表現で定義するときは大文字で始め，そうでなければ，小文字で始める。文字列リテラルは，引用符で囲む。
<!--* The distinction between symbols which can and cannot be
recognized using simple regular expressions may be used to set the
boundary between an implementation's lexical scanner and its parser,
but this specification neither constrains the placement of that
boundary nor presupposes that all implementations will have one. *-->
</p>

<p>規則の右側の式内では，一つ又は複数の文字からなる文字列とマッチするために，次の式を使用する。
<glist>
<gitem>
<label><code>#xN</code></label>
<def><p>ここで，<code>N</code>は16進の整数とする。ISO/IEC 10646の文字であって，正規形(UCS-4)のコード値を符号なし2進数として解釈したとき，指定した値と等しいものとマッチする。<code>#xN</code>形式の先頭にゼロがいくつか現れるかは，意味をもたない。コード値<!-- bit string -->における先頭のゼロの数は，文字の符号化によって決定されるので，XMLにとっては意味がない。
</p></def>
</gitem>
<gitem>
<label><code>[a-zA-Z]</code>, <code>[#xN-#xN]</code></label>
<def><p>指定した範囲の値(両端の値を含む。）をもつ任意の<termref def="dt-character">文字</termref>とマッチする。</p></def>
</gitem>
<gitem>
<label><code>[^a-z]</code>, <code>[^#xN-#xN]</code></label>
<def><p>指定した範囲<emph>外</emph>の値をもつ任意の<termref def="dt-character">文字</termref>とマッチする。</p></def>
</gitem>
<gitem>
<label><code>[^abc]</code>, <code>[^#xN#xN#xN]</code></label>
<def><p>指定した文字以外の値をもつ任意の<termref def="dt-character">文字</termref>とマッチする。</p></def>
</gitem>
<gitem>
<label><code>"string"</code></label>
<def><p>二重引用符で囲む文字列リテラルと<termref def="dt-match">マッチしている</termref>文字列リテラルとマッチする。</p></def>
</gitem>
<gitem>
<label><code>'string'</code></label>
<def><p>一重引用符で囲む文字列リテラルと<termref def="dt-match">マッチしている</termref>文字列リテラルとマッチする。</p></def>
</gitem>
</glist>
これらの記号は，次の形式の組合せで使用する。ここで，<code>A</code>及び<code>B</code>は，単純な式とする。
<glist>
<gitem>
<label>(<code>expression</code>)</label>
<def><p><code>expression</code>は，一つのまとまりとして扱い，ここに示す組合せで使ってもよい。</p></def>
</gitem>
<gitem>
<label><code>A?</code></label>
<def><p><code>A</code>又は何もなしとマッチする(オプションの<code>A</code>)。</p></def>
</gitem>
<gitem>
<label><code>A B</code></label>
<def><p><code>A</code>の次に<code>B</code>が出現するものとマッチする。
</p></def>
</gitem>
<gitem>
<label><code>A | B</code></label>
<def><p><code>A</code>又は<code>B</code>，ただし，両方ではない，とマッチする。
</p></def>
</gitem>
<gitem>
<label><code>A - B</code></label>
<def><p><code>A</code>とマッチするが，<code>B</code>とはマッチしない，任意の文字列とマッチする。</p></def>
</gitem>
<gitem>
<label><code>A+</code></label>
<def><p><code>A</code>の1回以上の繰返しとマッチする。</p></def>
</gitem>
<gitem>
<label><code>A*</code></label>
<def><p><code>A</code>の0回以上の繰返しとマッチする。</p></def>
</gitem>
<!-- DEATH TO %'s
<gitem>
<label><code>%a</code></label>
<def><p>specifies that <emph>in the external DTD subset</emph> a
<termref def='dt-param-entity'>parameter entity</termref> may occur in the
text at the position where <code>a</code> may occur; if so, its
replacement text must match <code>S? a S?</code>.  If
the expression <code>a</code> is governed by a suffix operator, then
the suffix operator determines both the maximum number of parameter-entity 
references allowed and the number of occurrences of <code>a</code>
in the replacement text of the parameter entities:  <code>%a*</code>
means that <code>a</code> must occur zero or more times, and
that some of its occurrences may be replaced by references to
parameter entities whose replacement text must contain zero or 
more occurrences of <code>a</code>; it is thus a more compact way
of writing <code>%(a*)*</code>.
Similarly, <code>%a+</code> means that <code>a</code>
must occur one or more times, and may be replaced by 
parameter entities with replacement text matching 
<code>S? (a S?)+</code>.  
The recognition of parameter entities in the internal subset is much more
highly constrained.
</p></def>
</gitem>
-->
</glist>
生成規則内で使用する他の記法を，次に示す。
<glist>
<gitem>
<label><code>/* ... */</code></label>
<def><p>コメント。</p></def>
</gitem>
<gitem>
<label><code>[ wfc: ... ]</code></label>
<def><p>整形式制約。生成規則に付与した，<termref def="dt-wellformed">整形式</termref>の文書に関する制約を，名前によって特定する。</p></def>
</gitem>
<gitem>
<label><code>[ vc: ... ]</code></label>
<def><p>妥当性制約。生成規則に付与した，<termref def="dt-valid">妥当</termref>な文書に関する制約を，名前によって特定する。
</p></def>
</gitem>
</glist>
</p></div1>

</body>
<back>
<!-- &SGML; -->

<!-- &Biblio; -->
<div1 id="sec-bibliography">

<head>参考文献</head>
<div2 id="sec-existing-stds">
<head>規定の参考文献</head>
<!--* <ulist><item>
<p>Unicode and ISO/IEC 10646.  This specification depends on the
international standard ISO/IEC 10646 (with amendments AM 1 through AM 7)
and the Unicode Standard, Version 2.0 <bibref ref='Unicode'/>, 
which define the encodings and meanings of
the <termref def="dt-character">characters</termref> which 
make up XML <termref def="dt-text">text</termref>.
All the characters in ISO/IEC 10646 are present, at the same code points, 
in Unicode.</p></item>
<item><p>XXX XXX defines the syntax and semantics of 
Uniform Resource Identifiers, or URIs.</p></item>
<item><p>IETF RFC 1766, with ISO 639 and 3166, 
describe the codes that may be used in the 
special <titleref href='sec-lang-tag'>xml:lang</titleref> attribute.</p>
</item></ulist>
*-->

<blist>

<bibl id="RFC1766" key="IETF RFC 1766">
IETF (Internet Engineering Task Force).
<emph>RFC 1766:  Tags for the Identification of Languages</emph>,
ed. H. Alvestrand.
1995.
</bibl>

<bibl id="ISO639" key="ISO 639">
(International Organization for Standardization).
<emph>ISO 8879:1988 (E).
Code for the representation of names of languages.</emph>
[Geneva]:  International Organization for
Standardization, 1988.</bibl>

<bibl id="ISO3166" key="ISO 3166">
(International Organization for Standardization).
<emph>ISO 3166-1:1997 (E).
Codes for the representation of names of countries and their subdivisions 
-- Part 1: Country codes</emph>
[Geneva]:  International Organization for
Standardization, 1997.</bibl>

<bibl id="ISO10646" key="ISO/IEC 10646">ISO
(International Organization for Standardization).
<emph>ISO/IEC 10646-1993 (E).  Information technology -- Universal
Multiple-Octet Coded Character Set (UCS) -- Part 1:
Architecture and Basic Multilingual Plane.</emph>
[Geneva]:  International Organization for
Standardization, 1993 (plus amendments AM 1 through AM 7).
</bibl>

<bibl id="Unicode" key="Unicode">The Unicode Consortium.
<emph>The Unicode Standard, Version 2.0.</emph>
Reading, Mass.:  Addison-Wesley Developers Press, 1996.</bibl>

</blist>

</div2>

<div2><head>他の参考文献</head> 

<blist>

<bibl id="Aho" key="Aho/Ullman">Aho, Alfred V., 
Ravi Sethi, and Jeffrey D. Ullman.
<emph>Compilers:  Principles, Techniques, and Tools</emph>.
Reading:  Addison-Wesley, 1986, rpt. corr. 1988.</bibl>

<bibl id="Berners-Lee" xml-link="simple" key="Berners-Lee et al.">
Berners-Lee, T., R. Fielding, and L. Masinter.
<emph>Uniform Resource Identifiers (URI):  Generic Syntax and
Semantics</emph>.
1997.
(Work in progress; see updates to RFC1738.)</bibl>

<bibl id="ABK" key="Br&#252;ggemann-Klein">Br&#252;ggemann-Klein, Anne.
<emph>Regular Expressions into Finite Automata</emph>.
Extended abstract in I. Simon, Hrsg., LATIN 1992, 
S. 97-98. Springer-Verlag, Berlin 1992. 
Full Version in Theoretical Computer Science 120: 197-213, 1993.
<!--
Universitat Freiburg, Institut fur Informatik,
Bericht 33, Juli 1991.-->
</bibl>

<bibl id="ABKDW" key="Br&#252;ggemann-Klein and Wood">Br&#252;ggemann-Klein, Anne,
and Derick Wood.
<emph>Deterministic Regular Languages</emph>.
Universit&#228;t Freiburg, Institut f&#252;r Informatik,
Bericht 38, Oktober 1991.
</bibl>

<bibl id="RFC1738" xml-link="simple" key="IETF RFC1738">
IETF (Internet Engineering Task Force).
<emph>RFC 1738:  Uniform Resource Locators (URL)</emph>, 
ed. T. Berners-Lee, L. Masinter, M. McCahill.
1994.
</bibl>

<bibl id="RFC1808" xml-link="simple" key="IETF RFC1808">
IETF (Internet Engineering Task Force).
<emph>RFC 1808:  Relative Uniform Resource Locators</emph>, 
ed. R. Fielding.
1995.
</bibl>

<bibl id="RFC2141" xml-link="simple" key="IETF RFC2141">
IETF (Internet Engineering Task Force).
<emph>RFC 2141:  URN Syntax</emph>, 
ed. R. Moats.
1997.
</bibl>

<bibl id="ISO8879" key="ISO/IEC 8879">ISO
(International Organization for Standardization).
<emph>ISO/IEC 8879-1986 (E).  Information processing -- Text and Office
Systems -- Standard Generalized Markup Language (SGML).</emph>  First
edition -- 1986-10-15.  [Geneva]:  International Organization for
Standardization, 1986.
</bibl>


<bibl id="ISO10744" key="ISO/IEC 10744">ISO
(International Organization for Standardization).
<emph>ISO/IEC 10744-1992 (E).  Information technology --
Hypermedia/Time-based Structuring Language (HyTime).
</emph>
[Geneva]:  International Organization for
Standardization, 1992.
<emph>Extended Facilities Annexe.</emph>
[Geneva]:  International Organization for
Standardization, 1996. 
</bibl>



</blist>
</div2>
</div1>
<div1 id="CharClasses">
<head>文字クラス</head>

<p>Unicode標準に定義するプロパティにしたがって，文字は，基底文字(BaseChar)(これらは，発音符を除くラテンアルファベットのアルファベット文字を含む)，統合漢字(ideographic)及び結合文字(CombiningChar)(このクラスは，ほとんどの発音符を含む)にクラス分けする。これらのクラスは，結合し，字(Letter)のクラスとなる。10進数値(Digit)及びエクステンダ(Extender)も区別する。
<scrap lang="ebnf" id="CHARACTERS">
<head>文字</head>
<prodgroup pcw3="3" pcw4="15">
<prod id="NT-Letter"><lhs>Letter</lhs>
<rhs><nt def="NT-BaseChar">BaseChar</nt> 
| <nt def="NT-Ideographic">Ideographic</nt></rhs> </prod>
<prod id="NT-BaseChar"><lhs>BaseChar</lhs>
<rhs>[#x0041-#x005A]
|&#160;[#x0061-#x007A]
|&#160;[#x00C0-#x00D6]
|&#160;[#x00D8-#x00F6]
|&#160;[#x00F8-#x00FF]
|&#160;[#x0100-#x0131]
|&#160;[#x0134-#x013E]
|&#160;[#x0141-#x0148]
|&#160;[#x014A-#x017E]
|&#160;[#x0180-#x01C3]
|&#160;[#x01CD-#x01F0]
|&#160;[#x01F4-#x01F5]
|&#160;[#x01FA-#x0217]
|&#160;[#x0250-#x02A8]
|&#160;[#x02BB-#x02C1]
|&#160;#x0386
|&#160;[#x0388-#x038A]
|&#160;#x038C
|&#160;[#x038E-#x03A1]
|&#160;[#x03A3-#x03CE]
|&#160;[#x03D0-#x03D6]
|&#160;#x03DA
|&#160;#x03DC
|&#160;#x03DE
|&#160;#x03E0
|&#160;[#x03E2-#x03F3]
|&#160;[#x0401-#x040C]
|&#160;[#x040E-#x044F]
|&#160;[#x0451-#x045C]
|&#160;[#x045E-#x0481]
|&#160;[#x0490-#x04C4]
|&#160;[#x04C7-#x04C8]
|&#160;[#x04CB-#x04CC]
|&#160;[#x04D0-#x04EB]
|&#160;[#x04EE-#x04F5]
|&#160;[#x04F8-#x04F9]
|&#160;[#x0531-#x0556]
|&#160;#x0559
|&#160;[#x0561-#x0586]
|&#160;[#x05D0-#x05EA]
|&#160;[#x05F0-#x05F2]
|&#160;[#x0621-#x063A]
|&#160;[#x0641-#x064A]
|&#160;[#x0671-#x06B7]
|&#160;[#x06BA-#x06BE]
|&#160;[#x06C0-#x06CE]
|&#160;[#x06D0-#x06D3]
|&#160;#x06D5
|&#160;[#x06E5-#x06E6]
|&#160;[#x0905-#x0939]
|&#160;#x093D
|&#160;[#x0958-#x0961]
|&#160;[#x0985-#x098C]
|&#160;[#x098F-#x0990]
|&#160;[#x0993-#x09A8]
|&#160;[#x09AA-#x09B0]
|&#160;#x09B2
|&#160;[#x09B6-#x09B9]
|&#160;[#x09DC-#x09DD]
|&#160;[#x09DF-#x09E1]
|&#160;[#x09F0-#x09F1]
|&#160;[#x0A05-#x0A0A]
|&#160;[#x0A0F-#x0A10]
|&#160;[#x0A13-#x0A28]
|&#160;[#x0A2A-#x0A30]
|&#160;[#x0A32-#x0A33]
|&#160;[#x0A35-#x0A36]
|&#160;[#x0A38-#x0A39]
|&#160;[#x0A59-#x0A5C]
|&#160;#x0A5E
|&#160;[#x0A72-#x0A74]
|&#160;[#x0A85-#x0A8B]
|&#160;#x0A8D
|&#160;[#x0A8F-#x0A91]
|&#160;[#x0A93-#x0AA8]
|&#160;[#x0AAA-#x0AB0]
|&#160;[#x0AB2-#x0AB3]
|&#160;[#x0AB5-#x0AB9]
|&#160;#x0ABD
|&#160;#x0AE0
|&#160;[#x0B05-#x0B0C]
|&#160;[#x0B0F-#x0B10]
|&#160;[#x0B13-#x0B28]
|&#160;[#x0B2A-#x0B30]
|&#160;[#x0B32-#x0B33]
|&#160;[#x0B36-#x0B39]
|&#160;#x0B3D
|&#160;[#x0B5C-#x0B5D]
|&#160;[#x0B5F-#x0B61]
|&#160;[#x0B85-#x0B8A]
|&#160;[#x0B8E-#x0B90]
|&#160;[#x0B92-#x0B95]
|&#160;[#x0B99-#x0B9A]
|&#160;#x0B9C
|&#160;[#x0B9E-#x0B9F]
|&#160;[#x0BA3-#x0BA4]
|&#160;[#x0BA8-#x0BAA]
|&#160;[#x0BAE-#x0BB5]
|&#160;[#x0BB7-#x0BB9]
|&#160;[#x0C05-#x0C0C]
|&#160;[#x0C0E-#x0C10]
|&#160;[#x0C12-#x0C28]
|&#160;[#x0C2A-#x0C33]
|&#160;[#x0C35-#x0C39]
|&#160;[#x0C60-#x0C61]
|&#160;[#x0C85-#x0C8C]
|&#160;[#x0C8E-#x0C90]
|&#160;[#x0C92-#x0CA8]
|&#160;[#x0CAA-#x0CB3]
|&#160;[#x0CB5-#x0CB9]
|&#160;#x0CDE
|&#160;[#x0CE0-#x0CE1]
|&#160;[#x0D05-#x0D0C]
|&#160;[#x0D0E-#x0D10]
|&#160;[#x0D12-#x0D28]
|&#160;[#x0D2A-#x0D39]
|&#160;[#x0D60-#x0D61]
|&#160;[#x0E01-#x0E2E]
|&#160;#x0E30
|&#160;[#x0E32-#x0E33]
|&#160;[#x0E40-#x0E45]
|&#160;[#x0E81-#x0E82]
|&#160;#x0E84
|&#160;[#x0E87-#x0E88]
|&#160;#x0E8A
|&#160;#x0E8D
|&#160;[#x0E94-#x0E97]
|&#160;[#x0E99-#x0E9F]
|&#160;[#x0EA1-#x0EA3]
|&#160;#x0EA5
|&#160;#x0EA7
|&#160;[#x0EAA-#x0EAB]
|&#160;[#x0EAD-#x0EAE]
|&#160;#x0EB0
|&#160;[#x0EB2-#x0EB3]
|&#160;#x0EBD
|&#160;[#x0EC0-#x0EC4]
|&#160;[#x0F40-#x0F47]
|&#160;[#x0F49-#x0F69]
|&#160;[#x10A0-#x10C5]
|&#160;[#x10D0-#x10F6]
|&#160;#x1100
|&#160;[#x1102-#x1103]
|&#160;[#x1105-#x1107]
|&#160;#x1109
|&#160;[#x110B-#x110C]
|&#160;[#x110E-#x1112]
|&#160;#x113C
|&#160;#x113E
|&#160;#x1140
|&#160;#x114C
|&#160;#x114E
|&#160;#x1150
|&#160;[#x1154-#x1155]
|&#160;#x1159
|&#160;[#x115F-#x1161]
|&#160;#x1163
|&#160;#x1165
|&#160;#x1167
|&#160;#x1169
|&#160;[#x116D-#x116E]
|&#160;[#x1172-#x1173]
|&#160;#x1175
|&#160;#x119E
|&#160;#x11A8
|&#160;#x11AB
|&#160;[#x11AE-#x11AF]
|&#160;[#x11B7-#x11B8]
|&#160;#x11BA
|&#160;[#x11BC-#x11C2]
|&#160;#x11EB
|&#160;#x11F0
|&#160;#x11F9
|&#160;[#x1E00-#x1E9B]
|&#160;[#x1EA0-#x1EF9]
|&#160;[#x1F00-#x1F15]
|&#160;[#x1F18-#x1F1D]
|&#160;[#x1F20-#x1F45]
|&#160;[#x1F48-#x1F4D]
|&#160;[#x1F50-#x1F57]
|&#160;#x1F59
|&#160;#x1F5B
|&#160;#x1F5D
|&#160;[#x1F5F-#x1F7D]
|&#160;[#x1F80-#x1FB4]
|&#160;[#x1FB6-#x1FBC]
|&#160;#x1FBE
|&#160;[#x1FC2-#x1FC4]
|&#160;[#x1FC6-#x1FCC]
|&#160;[#x1FD0-#x1FD3]
|&#160;[#x1FD6-#x1FDB]
|&#160;[#x1FE0-#x1FEC]
|&#160;[#x1FF2-#x1FF4]
|&#160;[#x1FF6-#x1FFC]
|&#160;#x2126
|&#160;[#x212A-#x212B]
|&#160;#x212E
|&#160;[#x2180-#x2182]
|&#160;[#x3041-#x3094]
|&#160;[#x30A1-#x30FA]
|&#160;[#x3105-#x312C]
|&#160;[#xAC00-#xD7A3]
</rhs></prod>
<prod id="NT-Ideographic"><lhs>Ideographic</lhs>
<rhs>[#x4E00-#x9FA5]
|&#160;#x3007
|&#160;[#x3021-#x3029]
</rhs></prod>
<prod id="NT-CombiningChar"><lhs>CombiningChar</lhs>
<rhs>[#x0300-#x0345]
|&#160;[#x0360-#x0361]
|&#160;[#x0483-#x0486]
|&#160;[#x0591-#x05A1]
|&#160;[#x05A3-#x05B9]
|&#160;#x05BB#x05BD
|&#160;#x05BF
|&#160;[#x05C1-#x05C2]
|&#160;#x05C4
|&#160;#x064B#x0652
|&#160;#x0670
|&#160;[#x06D6-#x06DC]
|&#160;#x06DD#x06DF
|&#160;[#x06E0-#x06E4]
|&#160;[#x06E7-#x06E8]
|&#160;[#x06EA-#x06ED]
|&#160;[#x0901-#x0903]
|&#160;#x093C
|&#160;[#x093E-#x094C]
|&#160;#x094D
|&#160;[#x0951-#x0954]
|&#160;[#x0962-#x0963]
|&#160;[#x0981-#x0983]
|&#160;#x09BC
|&#160;#x09BE
|&#160;#x09BF
|&#160;[#x09C0-#x09C4]
|&#160;[#x09C7-#x09C8]
|&#160;[#x09CB-#x09CD]
|&#160;#x09D7
|&#160;[#x09E2-#x09E3]
|&#160;#x0A02
|&#160;#x0A3C
|&#160;#x0A3E
|&#160;#x0A3F
|&#160;[#x0A40-#x0A42]
|&#160;[#x0A47-#x0A48]
|&#160;[#x0A4B-#x0A4D]
|&#160;[#x0A70-#x0A71]
|&#160;[#x0A81-#x0A83]
|&#160;#x0ABC
|&#160;[#x0ABE-#x0AC5]
|&#160;[#x0AC7-#x0AC9]
|&#160;[#x0ACB-#x0ACD]
|&#160;[#x0B01-#x0B03]
|&#160;#x0B3C
|&#160;[#x0B3E-#x0B43]
|&#160;[#x0B47-#x0B48]
|&#160;[#x0B4B-#x0B4D]
|&#160;[#x0B56-#x0B57]
|&#160;[#x0B82-#x0B83]
|&#160;[#x0BBE-#x0BC2]
|&#160;[#x0BC6-#x0BC8]
|&#160;[#x0BCA-#x0BCD]
|&#160;#x0BD7
|&#160;[#x0C01-#x0C03]
|&#160;[#x0C3E-#x0C44]
|&#160;[#x0C46-#x0C48]
|&#160;[#x0C4A-#x0C4D]
|&#160;[#x0C55-#x0C56]
|&#160;[#x0C82-#x0C83]
|&#160;[#x0CBE-#x0CC4]
|&#160;[#x0CC6-#x0CC8]
|&#160;[#x0CCA-#x0CCD]
|&#160;[#x0CD5-#x0CD6]
|&#160;[#x0D02-#x0D03]
|&#160;[#x0D3E-#x0D43]
|&#160;[#x0D46-#x0D48]
|&#160;[#x0D4A-#x0D4D]
|&#160;#x0D57
|&#160;#x0E31
|&#160;[#x0E34-#x0E3A]
|&#160;[#x0E47-#x0E4E]
|&#160;#x0EB1
|&#160;[#x0EB4-#x0EB9]
|&#160;[#x0EBB-#x0EBC]
|&#160;[#x0EC8-#x0ECD]
|&#160;[#x0F18-#x0F19]
|&#160;#x0F35
|&#160;#x0F37
|&#160;#x0F39
|&#160;#x0F3E
|&#160;#x0F3F
|&#160;[#x0F71-#x0F84]
|&#160;[#x0F86-#x0F8B]
|&#160;[#x0F90-#x0F95]
|&#160;#x0F97
|&#160;[#x0F99-#x0FAD]
|&#160;[#x0FB1-#x0FB7]
|&#160;#x0FB9
|&#160;[#x20D0-#x20DC]
|&#160;#x20E1
|&#160;[#x302A-#x302F]
|&#160;#x3099
|&#160;#x309A
</rhs></prod>
<prod id="NT-Digit"><lhs>Digit</lhs>
<rhs>[#x0030-#x0039]
|&#160;[#x0660-#x0669]
|&#160;[#x06F0-#x06F9]
|&#160;[#x0966-#x096F]
|&#160;[#x09E6-#x09EF]
|&#160;[#x0A66-#x0A6F]
|&#160;[#x0AE6-#x0AEF]
|&#160;[#x0B66-#x0B6F]
|&#160;[#x0BE7-#x0BEF]
|&#160;[#x0C66-#x0C6F]
|&#160;[#x0CE6-#x0CEF]
|&#160;[#x0D66-#x0D6F]
|&#160;[#x0E50-#x0E59]
|&#160;[#x0ED0-#x0ED9]
|&#160;[#x0F20-#x0F29]
</rhs></prod>
<prod id="NT-Extender"><lhs>Extender</lhs>
<rhs>#x00B7
|&#160;#x02D0
|&#160;#x02D1
|&#160;#x0387
|&#160;#x0640
|&#160;#x0E46
|&#160;#x0EC6
|&#160;#x3005
|&#160;[#x3031-#x3035]
|&#160;[#x309D-#x309E]
|&#160;[#x30FC-#x30FE]
</rhs></prod>

</prodgroup>
</scrap>
</p>
<p>ここで定義する文字クラスは，Unicode文字データベースから，次のとおりに得ることができる。
<ulist>
<item>
<p>a) 名前開始文字は，Ll, Lu, Lo, Lt, Nlカテゴリ内の一つでなければならない。</p>
</item>
<item>
<p>b) 名前開始文字以外の名前文字は，Mc, Me, Mn, Lm, Ndカテゴリ内の一つでなければならない。</p>
</item>
<item>
<p>c) 互換性領域にある文字(文字符号で#xF900より大きく#xFFFEより小さい文字)は，XMLにおける名前としては，許されない。</p>
</item>
<item>
<p>d) フォント分解か互換性分解をもつ文字(つまり，データベース内の５番目のフィールドに"compatibility formatting tag"があるもの。これは，５番目のフィールドが，"&lt;"で始まることによってマーク付けされる。)は，許されない。</p>
</item>
<item>
<p>e) 次の文字は，名前開始文字として扱う。これは，プロパティファイルが，これらの文字をアルファベットに類似すると見なすことによる。それらは
[#x02BB-#x02C1], #x0559, #x06E5, #x06E6とする。</p>
</item>
<item>
<p>f) 文字符号が#x20DD-#x20E0の文字は，(Unicode の5.14にしたがって)除外する。</p>
</item>
<item>
<p>g) 文字符号が#x00B7の文字は，プロパティリストにしたがって，エクステンダ(extender)に分類する。</p>
</item>
<item>
<p>h) 文字#x0387は，これに相当する正規形が#x00B7なので，名前文字に追加する。</p>
</item>
<item>
<p>i) 文字':'及び'_'は，名前開始文字として許す。</p>
</item>
<item>
<p>j) 文字'-'及び'.'は，名前文字として許す。</p>
</item>
</ulist>
</p>
</div1>
<inform-div1 id="sec-xml-and-sgml">
<head>XML及びSGML</head>

<p>XMLは，SGMLのサブセットとして設計されている。すなわち，すべての<termref def="dt-valid">妥当</termref>なXML文書は，規格に適合するSGML文書にもなる。SGMLが文書に課す制限以外に，XMLがいかなる制限を課すかに関する詳細は，別の<loc href="http://www.w3.org/TR/NOTE-sgml-xml">規程</loc>を参照のこと。この規程は，XMLの制約条件を示すSGML宣言を含み，これは，SGMLパーサに使用できる。
</p>
</inform-div1>
<inform-div1 id="sec-entexpand">
<head>実体参照及び文字参照の展開</head>
<p>この付録は，実体参照及び文字参照を認識し，展開する，一連の流れを，例に使って示す。</p>
<p>
DTDが，次の宣言を含む場合を考える。
<eg><![CDATA[<!ENTITY example "<p>An ampersand (&#38;#38;) may be escaped
numerically (&#38;#38;#38;) or with a general entity
(&amp;amp;).</p>" >
]]></eg>
XMLプロセサは，実体の宣言を構文解析した時点で文字参照を認識し，これを解決する。実体"<code>example</code>"の値として，次の文字列を保存する。
<eg><![CDATA[<p>An ampersand (&#38;) may be escaped
numerically (&#38;#38;) or with a general entity
(&amp;amp;).</p>
]]></eg>
文書内で"<code>&amp;example;</code>"を参照すると，このテキストは，再び構文解析される。このとき，要素"<code>p</code>"の開始タグ及び終了タグを認識し，三つの参照を認識し展開する。その結果，要素"<code>p</code>"は，次の内容をもつ(すべてデータとし，区切り子又はマーク付けは存在しない。)。
<eg><![CDATA[An ampersand (&) may be escaped
numerically (&#38;) or with a general entity
(&amp;).
]]></eg>
</p>
<p>規則及びその効果をより詳細に示すため，さらに複雑な例を示す。次の例で，行番号は，参照の便宜のためだけに付ける。
2 <!DOCTYPE test [
3 <!ELEMENT test (#PCDATA) >
4 <!ENTITY % xx '&#37;zz;'>
5 <!ENTITY % zz '&#60;!ENTITY tricky "error-prone" >' >
6 %xx;
7 ]>
8 <test>This sample shows a &tricky; method.</test>
]]></eg>
これを処理すると，次のとおりとなる。
<ulist spacing="compact">
<item><p>a) 4行目で，37番目の文字への参照を直ちに展開し，パラメタ実体"<code>xx</code>"を，シンボルテーブルに"<code>%zz;</code>"という値とともに保存する。置換テキストを再び走査することはないので，パラメタ実体"<code>zz</code>"への参照は認識しない("<code>zz</code>"は，まだ宣言されていないので，走査されれば，エラーとなる。)。</p></item>
<item><p>b) 5行目で，文字参照"<code>&amp;#60;</code>"を直ちに展開し，パラメタ実体"<code>zz</code>"を"<code>&lt;!ENTITY tricky "error-prone" &gt;</code>"という置換テキストとともに保存する。これは，整形式の実体宣言とする。</p></item>
<item><p>c) 6行目で，"<code>xx</code>"への参照を認識し，"<code>xx</code>"の置換テキスト(すなわち，"<code>%zz;</code>")を構文解析する。"<code>zz</code>"への参照を続いて認識し，置換テキスト("<code>&lt;!ENTITY tricky "error-prone" &gt;</code>")を構文解析する。一般実体"<code>tricky</code>"は，この時点では，宣言されており，その置換テキストは，"<code>error-prone</code>"とする。 </p></item>
<item><p>d) 8行目で，一般実体"<code>tricky</code>"への参照を認識し，展開する。要素"<code>test</code>"の完全な内容は，次の(内容をそれ自体表現する。)文字列となる。つまり，<emph>This sample shows a error-prone method.</emph>
</p></item>
</ulist>
</p>
</inform-div1> 
<inform-div1 id="determinism">
<head>決定的内容モデル</head>
<p><termref def="dt-compat">互換性のため</termref>，要素宣言における内容モデルは，決定的とする必要がある。
</p>
<!-- FINAL EDIT:  WebSGML allows ambiguity? -->
<p>SGMLは，決定的内容モデル(SGMLでは，非あいまいと呼ぶ。)を要求する。SGMLシステムを用いて作成したXMLプロセサは，非決定的内容モデルをエラーとしてもよい。</p>
<p>例えば，内容モデル<code>((b, c) | (b, d))</code>は非決定的となる。これは，最初に<code>b</code>を与えたとき，モデル内のいずれの<code>b</code>とマッチするのが望ましいか，その次の要素を先読みすることなしには，パーサは知ることができないことによる。この場合は，<code>b</code>への二つの参照は，一つの参照にまとめることができ，モデルは，<code>(b, (c | d))</code>となる。これで，最初の<code>b</code>が，内容モデル内の一つの名前とだけマッチすることは明らかとなる。パーサは，先読みして，次に来るものを知る必要がない。<code>c</code>も<code>d</code>も，受理される。</p>
<p>形式的に示す。Aho, Sethi, and Ullman <bibref ref="Aho"/>の3.9のアルゴリズム3.5の標準的なアルゴリズムを用いて，内容モデルから有限オートマトンを構成することができる。この種の多くのアルゴリズムでは，正規表現における各々の位置(つまり，正規表現の構文木における各々の末端ノード)に対して，follow set(次にどの位置に移動可能かを表すもの)を構成する。ある位置に対するfollow setにおいて，複数の位置が同じ要素型名でラベル付けされていれば，その内容モデルはエラーとなり，エラーを返す場合もある。
</p>
<p>すべての非決定的内容モデルを等価な決定的内容モデルに変換することはできないが，多くの非決定的内容モデルを変換するアルゴリズムが存在する。Br&#252;ggemann-Klein 1991 <bibref ref="ABK"/>を参照のこと。</p>
</inform-div1>
<inform-div1 id="sec-guessing">
<head>文字符号化の自動検出</head>
<p>
XMLの符号化宣言は，各実体の内部ラベルとして機能し，どの文字符号化を使用するかを示す。しかし，XMLプロセサは，内部ラベルを読む前に，どの文字符号化を使用するかを知る必要があり，これが，内部ラベルが示そうとすることになる。一般的には，これは，絶望的な状態となる。しかし，XMLにおいては，完全には絶望的ではない。これは，XMLが，次の二つの点で一般的な場合に対する制限を加えることによる。一つの制限は，どの実装も有限個の文字符号化だけのサポートを想定することとする。他の一つの制限は，各実体で使用する文字符号化を自動検出可能とする，XMLの符号化宣言の位置及び内容に関する制限とする。多くの場合に，XMLのデータストリームに加え，他の情報が利用できる。ここでは，XMLの実体がプロセサに渡されるとき，(外部)情報を伴うかどうかによって，二つの場合に分ける。まず最初の場合を示す。</p>
<p>
UTF-8形式又はUTF-16形式ではないXML実体は，最初の文字を‘<code>&lt;?xml</code>'とするXML符号化宣言で始まら<emph>なければならない</emph>ので，どの適合したプロセサも，入力にある2オクテット又は4オクテットを調べれば，次のどの場合があてはまるかを検出できる。このリストを読む際には，UCS-4の'&lt;'が"<code>#x0000003C</code>"，'?'が"<code>#x0000003F</code>"，及びUTF-16のデータストリームの必要とするバイト順マークが"<code>#xFEFF</code>"ということを知っておくと役立つかもしれない。</p>
<p>
<ulist>
<item>
<p>a) <code>00 00 00 3C</code>: UCS-4, big-endian マシン (1234順)</p>
</item>
<item>
<p>b) <code>3C 00 00 00</code>: UCS-4, little-endian マシン (4321順)</p>
</item>
<item>
<p>c) <code>00 00 3C 00</code>: UCS-4, 普通ではないオクテット順 (2143)</p>
</item>
<item>
<p>d) <code>00 3C 00 00</code>: UCS-4, 普通ではないオクテット順 (3412)</p>
</item>
<item>
<p>e) <code>FE FF</code>: UTF-16, big-endian</p>
</item>
<item>
<p>f) <code>FF FE</code>: UTF-16, little-endian</p>
</item>
<item>
<p>g) <code>00 3C 00 3F</code>: UTF-16, big-endian, バイト順マークなし(したがって，厳密にいえば，エラーとする。)。</p>
</item>
<item>
<p>h) <code>3C 00 3F 00</code>: UTF-16, little-endian, バイト順マークなし(したがって，厳密にいえば，エラーとする。)。</p>
</item>
<item>
<p>i) <code>3C 3F 78 6D</code>: UTF-8, ISO 646, ASCII, ISO 8859の各パート，Shift-JIS，EUC，並びに任意の他の7ビット，8ビット又は混在幅の符号化であって，ASCII文字を通常の位置，幅及び値とすることを保証するもの。これらのどれに対応するかを検出するためには，実際の符号化宣言を読み込まなければならない。しかし，これらすべての符号化は，ASCII文字に対して同じビットパターンを使用するので，符号化宣言自体は，正確に読込み可能とする。
</p>
</item>
<item>
<p>j) <code>4C 6F A7 94</code>: EBCDIC (又はその変種。どのコードページを使用するかを知るためには，符号化宣言全体を読み込まれなければならない。)</p>
</item>
<item>
<p>k) その他: 符号化宣言なしのUTF-8。そうでないときには，データストリームが壊れているか，断片的になっているか，何らかの形式にしたがって埋め込まれている。</p>
</item>
</ulist>
</p>
<p>
この程度の自動判別でも，XMLの符号化宣言を読み込み，文字符号化の識別子を解析するには十分とする。識別子の解析は，類似する各々の符号化の一つ一つを区別するために必要とする(例えば，UTF-8及び8859を区別するため，8859の各パートを区別するため，使用している特定のEBCDICコードページを区別するため，など。)。
</p>
<p>
符号化宣言の内容をASCII文字に限定しているので，どの分類の符号化を使用するかを検出すれば，プロセサは，符号化宣言全体を正確に読み込むことができる。現実問題として，広く使用されている文字符号化は，上の分類のいずれかにあてはまるので，オペレーティングシステム又は伝送プロトコルが与える外部情報を信頼不可能なときでさえも，内部ラベルで文字符号化をかなり正確に示すことが，XML符号化宣言によって可能となる。
</p>
<p>
プロセサが使用する文字符号化を検出しさえすれば，それぞれの場合に対して別個の入力ルーチンを呼び出す，又は入力する各文字に対し適切な変換関数を呼び出すことによって，適切な動作が可能となる。</p>
<p>
自分自体にラベル付けをするいかなるシステムでも同様だが，ソフトウェアが，符号化宣言を更新せずに実体の文字集合又は符号化を変えたならば，XMLの符号化宣言は，機能しない。文字符号化ルーチンの実装者は，実体のラベル付けに使用する内部及び外部の情報の正確さの保証に注意するのが望ましい。
</p>
<p>２番目の場合は，XMLの実体の他に，符号化情報が存在するときであって，いくつかのファイルシステム及びネットワークプロトコルでは，その符号化情報が存在する。複数の情報が利用できるとき，<!-- (e.g. both the
internal encoding declaration and an external label),  -->それらの相対的な優先度及びそれらが矛盾したときの望ましい処理方法は，XMLの配送に使用する，より高水準のプロトコルの一部として規程するのがよい。例えば，内部ラベル及び外部ヘッダに存在するMIME形式のラベルの相対的な優先度に対する規則は，text/xml及びapplication/xmlのMIME型を定義するRFC文書の一部となる方がよい。しかし，相互運用性のために，次の規則に従うことが望ましい。
<ulist>
<item><p>a) XMLの実体がファイルに存在すれば，バイト順マーク及び符号化宣言PIは，(存在すれば)文字符号化を決定するために使用する。他のすべてのヒューリスティック及び情報は，エラー回復のためだけに用いる。
</p></item>
<item><p>b) XMLの実体をMIME型text/xmlで配送するときは，このMIME型のもつcharsetパラメタが文字符号化方法を決定する。他のすべてのヒューリスティック及び情報は，エラー回復のためだけに用いる。
</p></item>
<item><p>c) XMLの実体を <!-- via the HTTP protocol -->MIME型application/xmlで配送するときは，バイト順マーク及び符号化宣言PIを(存在すれば)文字符号化の決定のために使用する。他のすべてのヒューリスティック及び情報はエラー回復のためだけに用いる。
</p></item>
</ulist>
これらの規則は，プロトコルについての資料がないときにだけ用いる。特に，MIME型text/xml及びapplication/xmlを定義したら，これらを規定するRFCに存在する規定が，これらの規則に取って代わる。
</p>
</inform-div1>
<!--
<div1 id='sec-trival-grammar'>
<head>A Trivial Grammar for XML Documents</head>
<p>The grammar given in the body of this specification is relatively
simple, but for some purposes it is convenient to have an even simpler
one.  
A very simple, though non-conforming, <termref def="dt-xml-proc">XML
processor</termref> could parse a <termref
def="dt-wellformed">well-formed</termref> XML document using the
following simplified grammar, recognizing all element boundaries
correctly, though not expanding entity references and not detecting
all errors:

<scrap lang="ebnf">
<head>Trivial text grammar</head>
<prodgroup pcw2="5.5" pcw4="17" pcw5="10">
<prod id='NT-simpleDoc'><lhs>simpleDoc</lhs>
<rhs>(<nt def='NT-SimpleData'>SimpleData</nt> 
| <nt def='NT-Markup'>Markup</nt>)*</rhs></prod>
<prod id="NT-SimpleData"><lhs>SimpleData</lhs>
<rhs>[^&lt;&amp;]*</rhs>
<com>cf. PCData</com>
</prod>
<prod id="NT-SimpleLit"><lhs>SimpleLit</lhs>
<rhs>('"' [^"]* '"')</rhs>
<rhs>|&nbsp;("'" [^']* "'")</rhs>
<com>cf. SkipLit</com>
</prod>
<prod id='NT-Markup'><lhs>Markup</lhs>
<rhs>'&lt;' <nt def='NT-Name'>Name</nt> 
(<nt def='NT-S'>S</nt> 
<nt def='NT-Name'>Name</nt> 
<nt def='NT-S'>S</nt>? '=' <nt def='NT-S'>S</nt>?
<nt def='NT-SimpleLit'>SimpleLit</nt>)* 
<nt def='NT-S'>S</nt>? '&gt;'</rhs><com>start-tags </com>
<rhs>| '&lt;' <nt def='NT-Name'>Name</nt> 
(<nt def='NT-S'>S</nt> 
<nt def='NT-Name'>Name</nt> 
<nt def='NT-S'>S</nt>? '=' <nt def='NT-S'>S</nt>?
<nt def='NT-SimpleLit'>SimpleLit</nt>)* 
<nt def='NT-S'>S</nt>? '/&gt;'</rhs><com>empty elements</com>
<rhs>| '&lt;/' 
<nt def='NT-Name'>Name</nt> 
<nt def='NT-S'>S</nt>? '&gt;'</rhs>
<com>end-tags </com>
<rhs>| '&amp;' <nt def='NT-Name'>Name</nt> ';'</rhs>
<com>entity references </com>
<rhs>| '&amp;#' [0-9]+ ';'</rhs>
<com>decimal character references </com>
<rhs>| '&hcro;' [0-9a-fA-F]+ ';'</rhs>
<com>hexadecimal character references </com>
<rhs>| '&lt;!&como;' 
(<nt def='NT-Char'>Char</nt>* - 
(<nt def='NT-Char'>Char</nt>* '&comc;' <nt def='NT-Char'>Char</nt>*))
'&comc;&gt;'</rhs>
<com>comments </com>
<rhs>| '&lt;?'
(<nt def='NT-Char'>Char</nt>* - 
(<nt def='NT-Char'>Char</nt>* &pic; <nt def='NT-Char'>Char</nt>*))
'&pic;'</rhs>
<com>processing instructions </com>
<rhs>| '&lt;![CDATA[' 
(<nt def='NT-Char'>Char</nt>* - 
(<nt def='NT-Char'>Char</nt>* ']]&gt;' <nt def='NT-Char'>Char</nt>*))
']]&gt;'</rhs>
<com>CDATA sections</com>
<rhs>| '&lt;!DOCTYPE' 
(<nt def="NT-Char">Char</nt> - ('[' | ']'))+
('[' 
<nt def="NT-simpleDTD">simpleDTD</nt>*
']')? '&gt;'</rhs>
<com>doc type declaration</com>
</prod>
<prod id="NT-simpleDTD"><lhs>simpleDTD</lhs>
<rhs>'&lt;!&como;' 
(<nt def='NT-Char'>Char</nt>* - 
(<nt def='NT-Char'>Char</nt>* '&comc;' <nt def='NT-Char'>Char</nt>*))
'&comc;&gt;'</rhs>
<com>comment </com>
<rhs>| '&lt;?'
(<nt def='NT-Char'>Char</nt>* - 
(<nt def='NT-Char'>Char</nt>* &pic; <nt def='NT-Char'>Char</nt>*))
'&pic;'</rhs>
<com>processing instruction </com>
<rhs><nt def="NT-SimpleLit">SimpleLit</nt></rhs>
<rhs>(<nt def="NT-Char">Char</nt> - (']' | '&lt;' | '"' | "'"))+
</rhs>

<rhs>'&lt;!' (<nt def="NT-Char">Char</nt> - ('-'))+</rhs>
<com>declarations other than comment</com>
</prod>
</prodgroup>
</scrap>
Most processors will require the more complex
grammar given in the body of this specification.

</p>
</div1>
-->

<inform-div1 id="sec-xml-wg">
<head>W3C XML ワーキンググループ</head>
 
<p>この仕様書は，W3C XML ワーキンググループ(WG)が準備し，公開を承認した。WGがこの仕様書を承認するということは，WGのすべての委員が承認投票を行ったということを必ずしも意味しない。XML WGの現在の委員及び以前の委員を次に示す。</p>
 
<!-- parens and spaces removed from role elements by bosak 1997.11.07 -->
<orglist>
<member><name>Jon Bosak, Sun</name><role>Chair</role></member>
<member><name>James Clark</name><role>Technical Lead</role></member>
<member><name>Tim Bray, Textuality and Netscape</name><role>XML Co-editor</role></member>
<member><name>Jean Paoli, Microsoft</name><role>XML Co-editor</role></member>
<member><name>C. M. Sperberg-McQueen, U. of Ill.</name><role>XML Co-editor</role></member>
<member><name>Dan Connolly, W3C</name></member>
<member><name>Steve DeRose, INSO</name></member>
<member><name>Dave Hollander, HP</name></member>
<member><name>Eliot Kimber, Highland</name></member>
<member><name>Eve Maler, ArborText</name></member>
<member><name>Tom Magliery, NCSA</name></member>
<member><name>Murray Maloney, Muzmo and Grif</name></member>
<member><name>村田　真，富士ゼロックス情報システム(株)</name></member>
<member><name>Joel Nava, Adobe</name></member>
<member><name>Peter Sharpe, SoftQuad</name></member>
<member><name>John Tigue, DataChannel</name></member>
</orglist>

</inform-div1>
</back>
</spec>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
End:
-->
